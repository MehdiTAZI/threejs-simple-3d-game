<!DOCTYPE html>
  <!--
  TODO :
    Organize code
    Add Physics and sound engines
    Add textures and 3D Objects
  -->
  <html>
    <head>
      <title>Breaker Game</title>
      <script src="https://cdn.jsdelivr.net/npm/three@0.119.1/build/three.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.119.1/examples/js/loaders/GLTFLoader.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.119.1/examples/js/loaders/RGBELoader.js"></script>
      <!--
      <script src="https://cdn.jsdelivr.net/npm/cannon@0.7.0/build/cannon.min.js"></script>
      -->
      <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAnUlEQVQ4T+WSwQ2DMBBFX1AEUpAEtKAP0KAHpYAO0KAHxwW3cym1iS3mZ93zz2cCcGwhCE2AGHcAiLkj4M9zQQux3ApsAHuABWkK8pPAJuK9aygJ6a1AFGx6SkgKiNR/xicqqLdJd1p1An0So2S1xgEtPYpMyg7MqNjD30tjNPkXvu5Bkrfbpv25CZVw4lIw5ruDc6gX2o37C6GQWJymSxhZ1aAAAAAElFTkSuQmCC" />
      <style>
        body {
          margin: 0;
          font-family: Arial, Helvetica, sans-serif;
          background: radial-gradient(circle at 30% 20%, #1f2937, #0f172a 55%, #020617 100%);
          color: #fff;
        }
        body::before {
          content: "";
          position: fixed;
          inset: 0;
          background: url('https://media.giphy.com/media/26AHONQ79FdWZhAI0/giphy.gif') center/cover no-repeat fixed;
          opacity: 0.2;
          mix-blend-mode: screen;
          pointer-events: none;
          z-index: -2;
          animation: bgFade 24s ease-in-out infinite;
        }
        canvas { width: 100%; height: 100%; display: block; }
        /* HUD */
        #hud {
          position: absolute;
          left: 12px;
          top: 12px;
          color: #fff;
          z-index: 10;
          padding: 10px 14px;
          background: rgba(17, 24, 39, 0.6);
          border-radius: 10px;
          backdrop-filter: blur(4px);
          text-shadow: 0 0 6px rgba(0,0,0,0.7);
        }
        #hud .line { margin-bottom: 6px; }
        #hud .metric { display: flex; align-items: baseline; gap: 6px; }
        #hud .label { font-size: 13px; letter-spacing: .04em; text-transform: uppercase; opacity: 0.7; }
        #hud .value { font-weight: 700; color: #4ade80; }
        #hud .value.alert { color: #facc15; }
        #controls {
          position: absolute;
          right: 12px;
          top: 12px;
          color: #fff;
          z-index: 10;
          text-align: right;
        }
        #controls .btn-row { margin-top: 6px; }
        .level-grid { margin-top: 10px; }
        .level-card {
          background: rgba(30, 41, 59, 0.85);
          border: 1px solid transparent;
          border-radius: 14px;
          padding: 18px;
          text-align: left;
          color: inherit;
          cursor: pointer;
          transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .level-card .title { font-size: 19px; font-weight: 700; margin-bottom: 6px; }
        .level-card .subtitle { font-size: 13px; color: #93c5fd; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 8px; }
        .level-card .description { font-size: 13px; color: #cbd5f5; margin-bottom: 10px; }
        .level-card .stats { font-size: 12px; color: #fbbf24; }
        .level-card:hover { transform: translateY(-3px); border-color: rgba(59, 130, 246, 0.68); box-shadow: 0 10px 24px rgba(30, 64, 175, 0.28); }
        .level-card.active { border-color: rgba(236, 72, 153, 0.8); box-shadow: 0 12px 28px rgba(236, 72, 153, 0.35); }
        #level-details { display: block; font-size: 13px; color: #cbd5f5; margin-right: 24px; }
        #selector-buttons {
          margin-top: 8px;
          display: flex;
          justify-content: flex-end;
          gap: 10px;
        }
        #selector-buttons button {
          background: rgba(129, 140, 248, 0.22);
          border: 1px solid rgba(129, 140, 248, 0.6);
          border-radius: 999px;
          padding: 7px 18px;
          color: #e0e7ff;
          font-size: 12px;
          cursor: pointer;
          transition: all 0.2s ease;
        }
        #selector-buttons button:hover { border-color: rgba(167, 139, 250, 0.9); color: #f5f3ff; }
        #paddle-open-btn {
          background: rgba(236, 72, 153, 0.18);
          border-color: rgba(244, 114, 182, 0.55);
          color: #ffe4f1;
        }
        #paddle-open-btn:hover { border-color: rgba(244, 114, 182, 0.85); color: #fff0f8; }
        #difficulty-info {
          margin-top: 6px;
          font-size: 11px;
          color: #cbd5f5;
          max-width: 260px;
          margin-left: auto;
        }
        #volume-control {
          margin-top: 10px;
          font-size: 12px;
          color: #bfdbfe;
        }
        #volume-control input[type="range"] {
          width: 160px;
          accent-color: #38bdf8;
        }
        #message {
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          color: #fff;
          z-index: 11;
          font-size: 24px;
          background: rgba(0,0,0,0.5);
          padding: 12px 18px;
          border-radius: 8px;
          display: none;
        }
        #achievements { margin-top: 8px; font-size: 12px; color: #ffeb3b; }
        #scene-banner {
          position: absolute;
          left: 50%;
          top: 14px;
          transform: translateX(-50%);
          color: #e0f2fe;
          font-size: 18px;
          letter-spacing: 0.04em;
          text-transform: uppercase;
          padding: 6px 12px;
          border-radius: 20px;
          background: rgba(8, 47, 73, 0.65);
          box-shadow: 0 0 12px rgba(14, 165, 233, 0.35);
          z-index: 9;
          opacity: 0.6;
          transition: opacity 0.8s ease;
        }
        @keyframes bgFade {
          0% { opacity: 0.18; }
          50% { opacity: 0.28; }
          100% { opacity: 0.18; }
        }
        .modal {
          position: fixed;
          inset: 0;
          background: rgba(10, 11, 25, 0.86);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 30;
          transition: opacity 0.4s ease;
        }
        .modal.hidden { opacity: 0; pointer-events: none; }
        .modal-content {
          background: rgba(15, 23, 42, 0.92);
          border: 1px solid rgba(148, 163, 184, 0.3);
          border-radius: 18px;
          padding: 28px 32px;
          max-width: 760px;
          width: 90%;
          box-shadow: 0 20px 60px rgba(2, 6, 23, 0.55);
          color: #e2e8f0;
        }
        .modal-content h2 {
          margin: 0 0 18px;
          font-size: 26px;
          text-align: center;
          letter-spacing: .04em;
        }
        .paddle-grid {
          display: grid;
          gap: 16px;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          margin-bottom: 18px;
        }
        .paddle-card {
          background: rgba(30, 41, 59, 0.85);
          border: 1px solid transparent;
          border-radius: 14px;
          padding: 18px;
          text-align: left;
          color: inherit;
          cursor: pointer;
          transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .paddle-card .title { font-size: 18px; font-weight: 700; margin-bottom: 10px; }
        .paddle-card .stats { font-size: 14px; color: #cbd5f5; margin-bottom: 8px; }
        .paddle-card .ability { font-size: 13px; color: #facc15; }
        .paddle-card:hover { transform: translateY(-3px); border-color: rgba(59, 130, 246, 0.7); box-shadow: 0 10px 24px rgba(30, 64, 175, 0.32); }
        .paddle-card.active { border-color: rgba(244, 114, 182, 0.9); box-shadow: 0 10px 26px rgba(236, 72, 153, 0.35); }
        .modal-footer {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 8px;
          font-size: 13px;
          color: #cbd5f5;
        }
        #select-confirm,
        #level-confirm {
          background: linear-gradient(135deg, #6366f1, #8b5cf6);
          border: none;
          border-radius: 999px;
          padding: 10px 22px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: opacity 0.2s ease;
        }
        #select-confirm:disabled,
        #level-confirm:disabled { opacity: 0.45; cursor: not-allowed; }
      </style>
    </head>
    <body>
      <canvas id="game-canvas"></canvas>

      <div id="hud">
        <div class="line metric"><span class="label">Score</span><span class="value" id="score">0</span></div>
        <div class="line metric"><span class="label">Best</span><span class="value" id="best-score">0</span></div>
        <div class="line metric"><span class="label">Combo</span><span class="value" id="combo">x1</span></div>
        <div class="line metric"><span class="label">Lives</span><span class="value" id="lives">3</span></div>
        <div class="line metric"><span class="label">Level</span><span class="value" id="level">1</span></div>
        <div class="line metric"><span class="label">Ability</span><span class="value" id="ability-status">—</span></div>
        <div class="line" style="margin-top:8px;font-size:12px;color:#bae6fd;">
          Quest: <span id="quest">—</span>
        </div>
        <div id="achievements">Achievements: <span id="ach-list">—</span></div>
      </div>

      <div id="scene-banner">Init</div>

      <div id="controls">
        <div>Controls: arrows / mouse - Magic: press F</div>
        <div class="btn-row"><button id="start-btn">Start</button> <button id="pause-btn">Pause</button> <button id="restart-btn">Restart</button> <button id="audio-btn">Audio: on</button></div>
        <div id="selector-buttons">
          <button id="level-open-btn">Select Level</button>
          <button id="paddle-open-btn">Select Paddle</button>
        </div>
        <div id="difficulty-info"></div>
        <div id="volume-control">Volume: <input id="volume-range" type="range" min="0" max="100" value="80" /></div>
      </div>

      <div id="message"></div>

      <div id="paddle-select" class="modal">
        <div class="modal-content">
          <h2>Choose your paddle</h2>
          <div class="paddle-grid">
            <button class="paddle-card" data-key="titan">
              <div class="title">Crimson Titan</div>
              <div class="stats">Wide reach - Heavy control</div>
              <div class="ability">Ability: Inferno strike — fiery ball burns nearby bricks</div>
            </button>
            <button class="paddle-card" data-key="aero">
              <div class="title">Azure Aero</div>
              <div class="stats">Ultra fast - Slim profile</div>
              <div class="ability">Ability: Ice barrier — conjures a rebound wall</div>
            </button>
            <button class="paddle-card" data-key="mystic">
              <div class="title">Violet Mystic</div>
              <div class="stats">Balanced - Precise control</div>
              <div class="ability">Ability: Time slow</div>
            </button>
          </div>
          <div class="modal-footer">
            <span id="paddle-details">Select a paddle to inspect its stats.</span>
            <button id="select-confirm" disabled>Confirm</button>
          </div>
        </div>
      </div>

      <div id="level-select-modal" class="modal hidden">
        <div class="modal-content">
          <h2>Select your mission</h2>
          <div class="paddle-grid level-grid">
            <button class="level-card active" data-key="nebula">
              <div class="title">Nebula Run</div>
              <div class="subtitle">Easy - Stage 1</div>
              <div class="description">Gentle ball speed and extra lives make it perfect for warm-ups.</div>
              <div class="stats">Music: Synthwave Nebula</div>
            </button>
            <button class="level-card" data-key="garden">
              <div class="title">Cosmic Bloom</div>
              <div class="subtitle">Normal - Stage 2</div>
              <div class="description">Balanced pace with the original challenge curve and rewards.</div>
              <div class="stats">Music: Cosmic Garden</div>
            </button>
            <button class="level-card" data-key="station">
              <div class="title">Orbital Siege</div>
              <div class="subtitle">Hard - Stage 3</div>
              <div class="description">Less margin for error, faster rebounds, and denser brick waves.</div>
              <div class="stats">Music: Orbital Station</div>
            </button>
            <button class="level-card" data-key="aurora">
              <div class="title">Aurora Peaks</div>
              <div class="subtitle">Chill - Stage 4</div>
              <div class="description">Icy cliffs with reflective snow banks and drifting platforms.</div>
              <div class="stats">Music: Aurora Peaks</div>
            </button>
            <button class="level-card" data-key="mirage">
              <div class="title">Desert Mirage</div>
              <div class="subtitle">Arid - Stage 5</div>
              <div class="description">Shimmering dunes, swirling sands, and mirage-triggered gusts.</div>
              <div class="stats">Music: Desert Mirage</div>
            </button>
            <button class="level-card" data-key="neon">
              <div class="title">Neon Shards</div>
              <div class="subtitle">Night - Stage 6</div>
              <div class="description">Hyper-speed neon rails, split lanes, and relentless combos.</div>
              <div class="stats">Music: Neon Shards</div>
            </button>
          </div>
          <div class="modal-footer">
            <span id="level-details">Nebula Run — Gentle ball speed and extra lives make it perfect for warm-ups.</span>
            <button id="level-confirm">Confirm</button>
          </div>
        </div>
      </div>

      <script>
        // Basic scene + renderer
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0 , 20);
        var target_view = new THREE.Vector3(0, 0, 0);
        camera.lookAt(target_view);

        var renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("game-canvas"), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111827);
        renderer.outputEncoding = THREE.sRGBEncoding;
        var clock = new THREE.Clock();
        var cameraBasePosition = new THREE.Vector3(0, -1.4, 20);
        camera.position.copy(cameraBasePosition);

        // Light
        var light = new THREE.PointLight(0xffffff, 1.2, 120);
        light.position.set(0, 0, 12);
        scene.add(light);
        var ambientLight = new THREE.AmbientLight(0x334155, 0.7);
        scene.add(ambientLight);

        var themeGroup = new THREE.Group();
        scene.add(themeGroup);

        // Background dome with soft gradient
        var backgroundUniforms = {
          colorTop: { value: new THREE.Color(0x0b1a32) },
          colorBottom: { value: new THREE.Color(0x111827) },
          time: { value: 0 }
        };

        function getRGBELoader(){
          if(hdriLoader) return hdriLoader;
          if(typeof THREE.RGBELoader === 'function'){
            hdriLoader = new THREE.RGBELoader();
            hdriLoader.setDataType(THREE.UnsignedByteType);
          }
          return hdriLoader;
        }
        var backgroundMaterial = new THREE.ShaderMaterial({
          side: THREE.BackSide,
          uniforms: backgroundUniforms,
          vertexShader: `
            varying float vHeight;
            void main(){
              vHeight = normalize(position).y * 0.5 + 0.5;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 colorTop;
            uniform vec3 colorBottom;
            uniform float time;
            varying float vHeight;
            void main(){
              float wave = sin(time * 0.1 + vHeight * 5.0) * 0.04;
              float mixVal = smoothstep(0.0, 1.0, vHeight + wave);
              vec3 col = mix(colorBottom, colorTop, mixVal);
              gl_FragColor = vec4(col, 1.0);
            }
          `
        });
        var backgroundSphere = new THREE.Mesh(new THREE.SphereGeometry(220, 48, 32), backgroundMaterial);
        scene.add(backgroundSphere);

        // Paddle (groupe + placeholder)
        var paddle = new THREE.Group();
        var paddlePlaceholderMaterial = new THREE.MeshStandardMaterial({ color: 0x60a5fa, metalness: 0.55, roughness: 0.3, emissive: 0x2563eb, emissiveIntensity: 0.5 });
        var paddleCenter = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 5.5, 32), paddlePlaceholderMaterial);
        paddleCenter.rotation.z = Math.PI / 2;
        var paddleCapLeft = new THREE.Mesh(new THREE.SphereGeometry(0.7, 28, 20), paddlePlaceholderMaterial);
        var paddleCapRight = paddleCapLeft.clone();
        paddleCapLeft.position.set(-2.8, 0, 0.2);
        paddleCapRight.position.set(2.8, 0, 0.2);
        paddle.add(paddleCenter);
        paddle.add(paddleCapLeft);
        paddle.add(paddleCapRight);
        var paddleGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xbae6fd, transparent: true, opacity: 0.32 });
        var paddleGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 6.2, 32), paddleGlowMaterial);
        paddleGlow.rotation.z = Math.PI / 2;
        paddle.add(paddleGlow);
        var paddleLight = new THREE.PointLight(0x93c5fd, 1.4, 18);
        paddleLight.position.set(0, 0, 1.2);
        paddle.add(paddleLight);
        var paddleFrameMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x1f4ed8, emissiveIntensity: 0.25, metalness: 0.8, roughness: 0.15 });
        var paddleFrame = new THREE.Mesh(new THREE.TorusGeometry(3, 0.15, 16, 48), paddleFrameMaterial);
        paddleFrame.rotation.set(Math.PI / 2, 0, 0);
        paddleFrame.position.set(0, 0, -0.3);
        paddle.add(paddleFrame);
        var paddleStrutMaterial = new THREE.MeshStandardMaterial({ color: 0xeff6ff, metalness: 0.7, roughness: 0.3, emissive: 0x1d4ed8, emissiveIntensity: 0.18 });
        var strutGeo = new THREE.BoxGeometry(0.3, 0.3, 1.6);
        var strutLeft = new THREE.Mesh(strutGeo, paddleStrutMaterial);
        var strutRight = strutLeft.clone();
        strutLeft.position.set(-2.2, 0, -0.2);
        strutRight.position.set(2.2, 0, -0.2);
        paddle.add(strutLeft);
        paddle.add(strutRight);
        paddle.position.set(0, -10, 0);
        scene.add(paddle);
        var paddleModel = null;
        var paddlePlaceholderParts = [paddleCenter, paddleCapLeft, paddleCapRight, paddleGlow, paddleFrame, strutLeft, strutRight];
        var paddleHitRadius = 3.2;
        var paddleVelocity = 0;
        var paddleTargetX = 0;
        var mouseTargetX = 0;
        var mouseControlActive = false;
        var paddleSmoothFactor = 0.18;
        var paddleSpeedCap = 2.4;
        paddleTargetX = paddle.position.x;
        updatePaddleHitRadius();
        loadPaddleModel();

        // Ball + light aura
        var ballGeometry = new THREE.IcosahedronGeometry(0.55, 2);
        var ballMaterial = new THREE.MeshStandardMaterial({
          color: 0x60a5fa,
          emissive: 0x2f88ff,
          emissiveIntensity: 0.65,
          metalness: 0.55,
          roughness: 0.25
        });
        var ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(0, -8, 0);
        var ballGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.7, 24, 18),
          new THREE.MeshBasicMaterial({ color: 0x90cdf4, transparent: true, opacity: 0.25 })
        );
        ball.add(ballGlow);
        var ballLight = new THREE.PointLight(0x6ec1ff, 1.3, 12);
        ballLight.position.set(0, 0, 0.5);
        ball.add(ballLight);
        scene.add(ball);
        var ballBaseColor = ballMaterial.color.clone();
        var ballBaseEmissive = ballMaterial.emissive.clone();
        var ballBaseEmissiveIntensity = ballMaterial.emissiveIntensity;
        var ballGlowBaseColor = ballGlow.material.color.clone();
        var ballGlowBaseOpacity = ballGlow.material.opacity;
        var ballLightBaseColor = ballLight.color.clone();
        var ballLightBaseIntensity = ballLight.intensity;

        var textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous');
        var hdriLoader = null;
        var gltfLoader = null;
        var brickTextureCache = {};
        var skyTextureCache = {};
        var particleTextures = {};

        function getGLTFLoader(onReady, attempt){
          attempt = attempt || 0;
          if(typeof THREE.GLTFLoader === 'function'){
            if(!gltfLoader){
              try {
                gltfLoader = new THREE.GLTFLoader();
              } catch(err){
                console.warn('GLTFLoader init failed', err);
                gltfLoader = null;
              }
            }
            if(gltfLoader){
              onReady(gltfLoader);
              return;
            }
          }
          if(attempt >= 25){
            console.warn('GLTFLoader non disponible: utilisation des placeholders.');
            onReady(null);
            return;
          }
          setTimeout(function(){ getGLTFLoader(onReady, attempt + 1); }, 200);
        }

        function getParticleTexture(hex){
          if(!hex) hex = '#ffffff';
          if(particleTextures[hex]) return particleTextures[hex];
          var size = 72;
          var canvas = document.createElement('canvas');
          canvas.width = canvas.height = size;
          var ctx = canvas.getContext('2d');
          var gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
          var color = new THREE.Color(hex);
          var inner = 'rgba(' + Math.round(Math.min(255, color.r * 280)) + ',' + Math.round(Math.min(255, color.g * 280)) + ',' + Math.round(Math.min(255, color.b * 280)) + ',1)';
          var mid = 'rgba(' + Math.round(color.r * 255) + ',' + Math.round(color.g * 255) + ',' + Math.round(color.b * 255) + ',0.6)';
          var outer = 'rgba(' + Math.round(color.r * 255) + ',' + Math.round(color.g * 255) + ',' + Math.round(color.b * 255) + ',0)';
          gradient.addColorStop(0, inner);
          gradient.addColorStop(0.45, mid);
          gradient.addColorStop(1, outer);
          ctx.fillStyle = gradient;
          ctx.fillRect(0,0,size,size);
          var texture = new THREE.CanvasTexture(canvas);
          texture.magFilter = THREE.LinearFilter;
          texture.minFilter = THREE.LinearFilter;
          texture.needsUpdate = true;
          particleTextures[hex] = texture;
          return texture;
        }

        function getBrickTexture(url){
          if(!url) return null;
          if(brickTextureCache[url]) return brickTextureCache[url];
          var tex = textureLoader.load(url, function(t){
            t.encoding = THREE.sRGBEncoding;
            t.wrapS = t.wrapT = THREE.RepeatWrapping;
            t.repeat.set(1.2, 0.8);
            if(renderer && renderer.capabilities){
              t.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy() || 1);
            }
          });
          tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
          brickTextureCache[url] = tex;
          return tex;
        }

        function applySkyTexture(theme, tex){
          if(!tex){
            scene.background = null;
            scene.environment = null;
            backgroundSphere.visible = true;
            return;
          }
          scene.background = tex;
          scene.environment = tex;
          backgroundSphere.visible = false;
        }

        function setSkyTexture(theme){
          var bg = theme.background || {};
          var url = bg.sky;
          if(!url){
            applySkyTexture(theme, null);
            return;
          }
          var cached = skyTextureCache[url];
          if(cached && cached.isTexture){
            applySkyTexture(theme, cached);
            return;
          }
          textureLoader.load(url, function(tex){
            tex.encoding = THREE.sRGBEncoding;
            tex.mapping = THREE.EquirectangularReflectionMapping;
            if(renderer && renderer.capabilities){
              tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy() || 1);
            }
            skyTextureCache[url] = tex;
            if(currentTheme === theme){
              applySkyTexture(theme, tex);
            }
          }, undefined, function(){
            skyTextureCache[url] = null;
            if(currentTheme === theme){
              applySkyTexture(theme, null);
            }
          });
        }

        // Bricks group
        var blockGeometry = new THREE.BoxGeometry(1, 0.6, 0.5, 2, 2, 2);
        var brickGroup = new THREE.Group();
        scene.add(brickGroup);
        var blocks = [];

        // Game state & HUD
        var gameState = 'menu'; // 'menu' | 'playing' | 'paused' | 'gameover'
        var score = 0;
        var defaultLives = 3;
        var lives = defaultLives;
        var level = 1;
        var achievements = {};
        var powerUps = [];
        var bestScore = loadBestScore();
        var comboCount = 0;
        var comboTimeout = null;
        var comboResetDelay = 1800;
        var quest = createQuest();
        var totalBlocksDestroyed = 0;

        var currentTheme = null;
        var currentThemeModel = null;
        var currentThemeBaseY = 0;
        var stageBanner = document.getElementById('scene-banner');
        var currentThemeMixer = null;
        var currentThemeAnimation = null;
        var audioEnabled = true;
        var audioUnlocked = false;
        var audioVolume = 0.8;
        var audioCtx = null;
        var masterGain = null;
        var sfxGain = null;
        var musicGain = null;
        var musicNodes = [];
        var currentMusicSource = null;
        var musicBuffers = {};
        var musicTrackLoading = {};
        var currentMusicTheme = null;
        var pendingMusicTheme = null;
        var musicTimer = null;
        var fireParticles = null;
        var fireParticleData = [];
        var fireParticlePositions = null;
        var iceParticles = null;
        var iceParticleData = [];
        var iceParticlePositions = null;
        var slowParticles = null;
        var slowParticleData = null;
        var brickBursts = [];
        var wizzEffects = [];
        var fadingBlocks = [];
        var paddleProfiles = {
          titan: {
            name: 'Crimson Titan',
            description: 'Wide reach, heavy handling',
            colors: { primary: 0xea3b5b, emissive: 0x9f1239, glow: 0xfca5a5, light: 0xff7b9d },
            scale: 1.55,
            smooth: 0.12,
            speedCap: 1.35,
            ability: { name: 'Inferno strike', type: 'fireball', cooldown: 16000, duration: 4000, radius: 2.6 }
          },
          aero: {
            name: 'Azure Aero',
            description: 'Ultra fast, slim profile',
            colors: { primary: 0x38bdf8, emissive: 0x1d4ed8, glow: 0x93c5fd, light: 0x60a5fa },
            scale: 0.9,
            smooth: 0.28,
            speedCap: 2.7,
            ability: { name: 'Ice barrier', type: 'iceWall', cooldown: 12000, duration: 5000 }
          },
          mystic: {
            name: 'Violet Mystic',
            description: 'Balanced, time control',
            colors: { primary: 0x8b5cf6, emissive: 0x5b21b6, glow: 0xc4b5fd, light: 0xa855f7 },
            scale: 1.1,
            smooth: 0.2,
            speedCap: 2.05,
            ability: { name: 'Time slow', type: 'slow', cooldown: 13000, duration: 5000, factor: 0.45 }
          }
        };
        var difficultyProfiles = {
          nebula: {
            name: 'Nebula Run',
            description: 'Generous lives and a calmer ball speed ideal for warm-ups.',
            startLevel: 1,
            lives: 5,
            speedMultiplier: 0.85,
            growthMultiplier: 0.75,
            maxSpeedMultiplier: 0.8,
            musicTheme: 'Synthwave Nebula'
          },
          garden: {
            name: 'Cosmic Bloom',
            description: 'Balanced challenge with standard lives and tempo.',
            startLevel: 2,
            lives: defaultLives,
            speedMultiplier: 1,
            growthMultiplier: 1,
            maxSpeedMultiplier: 1,
            musicTheme: 'Cosmic Garden'
          },
          station: {
            name: 'Orbital Siege',
            description: 'Fewer lives, faster ball, and a steeper speed curve.',
            startLevel: 3,
            lives: 2,
            speedMultiplier: 1.12,
            growthMultiplier: 1.25,
            maxSpeedMultiplier: 1.2,
            musicTheme: 'Orbital Station'
          },
          aurora: {
            name: 'Aurora Peaks',
            description: 'Icy ridges, reflective ice and gusty winds challenge positioning.',
            startLevel: 4,
            lives: 4,
            speedMultiplier: 0.95,
            growthMultiplier: 1.05,
            maxSpeedMultiplier: 1,
            musicTheme: 'Aurora Peaks'
          },
          mirage: {
            name: 'Desert Mirage',
            description: 'Shimmering dunes with erratic gusts and heat-driven rebounds.',
            startLevel: 5,
            lives: 3,
            speedMultiplier: 1.05,
            growthMultiplier: 1.2,
            maxSpeedMultiplier: 1.1,
            musicTheme: 'Desert Mirage'
          },
          neon: {
            name: 'Neon Shards',
            description: 'Hyper-fast rails, dense grids, and relentless ball acceleration.',
            startLevel: 6,
            lives: 2,
            speedMultiplier: 1.15,
            growthMultiplier: 1.3,
            maxSpeedMultiplier: 1.25,
            musicTheme: 'Neon Shards'
          }
        };
        var selectedPaddleKey = null;
        var selectedPaddleProfile = null;
        var selectedDifficultyKey = 'nebula';
        var abilityCooldownEnd = 0;
        var abilityActiveUntil = 0;
        var abilityReady = false;
        var abilityState = {
          fireballActive: false,
          fireballEnd: 0,
          fireballRadius: 2.5,
          slowTimeActive: false,
          slowEnd: 0,
          slowFactor: 0.5,
          iceWallActive: false,
          iceWallEnd: 0,
          iceWallMesh: null
        };
        var iceWallY = -11.3;

        function getSelectedDifficulty(){
          return difficultyProfiles[selectedDifficultyKey] || difficultyProfiles.nebula;
        }

        var ballDirection = new THREE.Vector3(0.7, 0.7, 0).normalize();
        var defaultBaseBallSpeed = 0.28;
        var defaultMaxBallSpeed = 0.62;
        var defaultBallSpeedGrowth = 0.015;
        var baseBallSpeed = defaultBaseBallSpeed;
        var ballSpeed = baseBallSpeed;
        var maxBallSpeed = defaultMaxBallSpeed;
        var ballSpeedGrowth = defaultBallSpeedGrowth;
        var tempVec1 = new THREE.Vector3();
        var tempVec2 = new THREE.Vector3();
        var playfieldHalfWidth = 28.5;

        function updateHUD(){
          document.getElementById('score').textContent = score;
          document.getElementById('lives').textContent = lives;
          document.getElementById('level').textContent = level;
          document.getElementById('best-score').textContent = bestScore;
          var comboValue = 'x' + comboMultiplier();
          var comboEl = document.getElementById('combo');
          comboEl.textContent = comboValue;
          if(comboMultiplier() > 1){ comboEl.classList.add('alert'); } else { comboEl.classList.remove('alert'); }

          var keys = Object.keys(achievements).filter(k => achievements[k]).join(', ');
          document.getElementById('ach-list').textContent = keys.length ? keys : '—';
          updateQuestHUD();
        }

        function showMessage(text, timeout){
          var el = document.getElementById('message');
          el.textContent = text;
          el.style.display = 'block';
          if(timeout) setTimeout(()=> el.style.display='none', timeout);
        }

        function loadBestScore(){
          try {
            var stored = window.localStorage.getItem('breaker-best-score');
            return stored ? parseInt(stored, 10) || 0 : 0;
          } catch(err) {
            console.warn('Stockage local indisponible', err);
            return 0;
          }
        }

        function saveBestScore(value){
          if(value > bestScore){
            bestScore = value;
            try { window.localStorage.setItem('breaker-best-score', bestScore); }
            catch(err){ console.warn('Impossible de sauvegarder le meilleur score', err); }
          }
        }

        function comboMultiplier(){
          return Math.max(1, 1 + Math.floor(comboCount / 3));
        }

        function resetCombo(){
          comboCount = 0;
          if(comboTimeout) { clearTimeout(comboTimeout); comboTimeout = null; }
        }

        function setBallDirection(x, y){
          var dir = new THREE.Vector3(x, y, 0);
          if(dir.lengthSq() === 0){
            dir.set(0.0001, 1, 0);
          }
          ballDirection.copy(dir.normalize());
        }

        function randomizeBallDirection(){
          var minAngle = THREE.Math.degToRad(35);
          var maxAngle = THREE.Math.degToRad(70);
          var angle = minAngle + Math.random() * (maxAngle - minAngle);
          var horizontal = Math.random() < 0.5 ? -1 : 1;
          setBallDirection(Math.sin(angle) * horizontal, Math.cos(angle));
          stabiliseBallDirection();
        }

        function resetBallPosition(){
          ball.position.set(0, -8, 0);
          randomizeBallDirection();
          ballSpeed = baseBallSpeed;
        }

        function stabiliseBallDirection(minY){
          minY = minY || 0.24;
          if(Math.abs(ballDirection.y) < minY){
            ballDirection.y = minY * (ballDirection.y >= 0 ? 1 : -1 || 1);
          }
          ballDirection.normalize();
        }

        function accelerateBall(multiplier){
          ballSpeed = Math.min(maxBallSpeed, ballSpeed * multiplier);
        }

        function boostCombo(){
          comboCount++;
          if(comboTimeout) clearTimeout(comboTimeout);
          comboTimeout = setTimeout(function(){ resetCombo(); updateHUD(); }, comboResetDelay);
        }

        function createQuest(){
          var target = 15 + Math.floor(Math.random() * 10);
          var reward = 120 + target * 8;
          return {
            description: 'Break ' + target + ' bricks',
            target: target,
            progress: 0,
            reward: reward,
            completed: false
          };
        }

        function updateQuestHUD(){
          var questEl = document.getElementById('quest');
          if(!quest){ questEl.textContent = '—'; return; }
          var progressText = quest.completed ? 'Done! +' + quest.reward : quest.progress + '/' + quest.target;
          if(!quest.completed) progressText += ' | +' + quest.reward;
          questEl.textContent = quest.description + ' (' + progressText + ')';
        }

        function tryCompleteQuest(){
          if(quest && !quest.completed && quest.progress >= quest.target){
            quest.completed = true;
            score += quest.reward;
            saveBestScore(score);
            showMessage('Quest complete! +' + quest.reward + ' pts', 2200);
            updateHUD();
            setTimeout(function(){ quest = createQuest(); updateQuestHUD(); }, 2500);
          }
        }

        function resetQuest(){
          quest = createQuest();
          updateQuestHUD();
        }

        function setSceneBanner(text){
          stageBanner.textContent = text;
          stageBanner.style.opacity = 1;
          setTimeout(function(){ stageBanner.style.opacity = 0.55; }, 1600);
        }

        var selectionModal = document.getElementById('paddle-select');
        var paddleCards = Array.prototype.slice.call(document.querySelectorAll('.paddle-card'));
        var selectConfirm = document.getElementById('select-confirm');
        var paddleDetails = document.getElementById('paddle-details');
        var abilityStatusEl = document.getElementById('ability-status');

        function openSelectionModal(){
          selectionModal.classList.remove('hidden');
          if(audioEnabled){
            pendingMusicTheme = 'Start Screen';
            if(!audioUnlocked){
              ensureAudioReady();
            } else {
              startThemeMusic('Start Screen');
            }
          }
          highlightSelectedPaddleCard();
        }

        function closeSelectionModal(){
          selectionModal.classList.add('hidden');
        }

        function applyPaddleProfile(key){
          var profile = paddleProfiles[key];
          if(!profile) return;
          selectedPaddleKey = key;
          selectedPaddleProfile = profile;
          paddle.scale.set(profile.scale, 1, 1);
          paddleSmoothFactor = profile.smooth;
          paddleSpeedCap = profile.speedCap;
          paddlePlaceholderMaterial.color.setHex(profile.colors.primary);
          paddlePlaceholderMaterial.emissive.setHex(profile.colors.emissive);
          paddleGlowMaterial.color.setHex(profile.colors.glow);
          paddleFrameMaterial.color.setHex(0xffffff);
          paddleFrameMaterial.emissive.setHex(profile.colors.glow);
          paddleFrameMaterial.emissiveIntensity = 0.28;
          paddleStrutMaterial.color.setHex(0xf8fafc);
          paddleStrutMaterial.emissive.setHex(profile.colors.emissive);
          paddleStrutMaterial.emissiveIntensity = 0.22;
          paddleLight.color.setHex(profile.colors.light);
          paddleLight.intensity = 1.5;
          updatePaddleHitRadius();
          clampPaddlePosition();
          paddleTargetX = paddle.position.x;
          resetAbilityState();
          updateAbilityUI();
          updatePaddleButtonLabel();
        }

        function resetAbilityState(){
          abilityCooldownEnd = 0;
          abilityActiveUntil = 0;
          abilityReady = !!selectedPaddleProfile;
          abilityState.fireballActive = false;
          abilityState.fireballEnd = 0;
          abilityState.fireballRadius = 2.5;
          restoreBallAppearance();
          abilityState.slowTimeActive = false;
          abilityState.slowEnd = 0;
          abilityState.slowFactor = 0.5;
          deactivateIceWall();
          if(slowParticles) slowParticles.visible = false;
        }

        paddleCards.forEach(function(card){
          card.addEventListener('click', function(){
            paddleCards.forEach(c => c.classList.remove('active'));
            card.classList.add('active');
            var key = card.getAttribute('data-key');
            var profile = paddleProfiles[key];
            if(profile){
              paddleDetails.textContent = profile.description + ' — ability: ' + profile.ability.name + ' (press F)';
              selectConfirm.disabled = false;
              selectConfirm.setAttribute('data-key', key);
            }
          });
        });

        selectConfirm.addEventListener('click', function(){
          var key = selectConfirm.getAttribute('data-key');
          if(!key) return;
          applyPaddleProfile(key);
          closeSelectionModal();
        });

        var sfxPresets = {
          paddle: { freq: 540, freqEnd: 420, attack: 0.01, release: 0.18, gain: 0.35, type: 'triangle' },
          block: { freq: 500, freqEnd: 360, attack: 0.015, release: 0.22, gain: 0.32, type: 'sine' },
          powerup: { freq: 660, freqEnd: 880, attack: 0.02, release: 0.45, gain: 0.28, type: 'sine' },
          lifeLost: { freq: 220, freqEnd: 120, attack: 0.03, release: 0.8, gain: 0.35, type: 'sawtooth' },
          levelUp: { freq: 520, freqEnd: 780, attack: 0.02, release: 0.5, gain: 0.32, type: 'triangle' },
          gameOver: { freq: 150, freqEnd: 70, attack: 0.04, release: 1.2, gain: 0.38, type: 'triangle' },
          magicFire: { freq: 420, freqEnd: 920, attack: 0.01, release: 0.6, gain: 0.5, type: 'sawtooth' },
          magicIce: { freq: 540, freqEnd: 260, attack: 0.02, release: 0.8, gain: 0.42, type: 'triangle' },
          magicSlow: { freq: 320, freqEnd: 240, attack: 0.05, release: 1.1, gain: 0.38, type: 'sine' }
        };

        var musicPresets = {
          'Synthwave Nebula': {
            volume: 0.26,
            waveform: 'sine',
            noteGain: 0.08,
            filter: { type: 'lowpass', freq: 780, Q: 0.7 },
            chords: [
              { notes: [220, 330, 440], duration: 4.5, attack: 1.2, release: 1.6, pause: 1.3 },
              { notes: [247, 370, 494], duration: 4.6, attack: 1.4, release: 1.7, pause: 1.4 },
              { notes: [196, 294, 392], duration: 5.2, attack: 1.3, release: 1.9, pause: 1.6 }
            ]
          },
          'Cosmic Garden': {
            volume: 0.23,
            waveform: 'triangle',
            noteGain: 0.07,
            filter: { type: 'lowpass', freq: 560, Q: 0.9 },
            chords: [
              { notes: [261.63, 329.63, 392.00], duration: 6.0, attack: 1.8, release: 2.2, pause: 1.8 },
              { notes: [293.66, 369.99, 440.00], duration: 5.6, attack: 1.6, release: 2.0, pause: 1.5 }
            ]
          },
          'Orbital Station': {
            volume: 0.25,
            waveform: 'sawtooth',
            noteGain: 0.065,
            filter: { type: 'lowpass', freq: 980, Q: 0.6 },
            chords: [
              { notes: [207.65, 311.13, 415.30], duration: 5.2, attack: 1.2, release: 1.8, pause: 1.2 },
              { notes: [233.08, 349.23, 466.16], duration: 4.8, attack: 1.1, release: 1.7, pause: 1.1 },
              { notes: [185.00, 277.18, 369.99], duration: 5.4, attack: 1.4, release: 2.0, pause: 1.3 }
            ]
          },
          default: {
            volume: 0.2,
            waveform: 'sine',
            noteGain: 0.07,
            filter: { type: 'lowpass', freq: 650, Q: 0.8 },
            chords: [
              { notes: [220, 330, 440], duration: 5.4, attack: 1.3, release: 1.9, pause: 1.5 }
            ]
          }
        };

        var musicTracks = {
          'Start Screen': {
            url: 'resources/start.mp3',
            volume: 0.2,
            loop: true
          },
          'Synthwave Nebula': {
            url: 'resources/background1.mp3',
            volume: 0.26,
            loop: true
          },
          'Cosmic Garden': {
            url: 'resources/background2.mp3',
            volume: 0.24,
            loop: true
          },
          'Orbital Station': {
            url: 'resources/background3.mp3',
            volume: 0.25,
            loop: true
          },
          'Aurora Peaks': {
            url: 'resources/background1.mp3',
            volume: 0.22,
            loop: true
          },
          'Desert Mirage': {
            url: 'resources/background2.mp3',
            volume: 0.27,
            loop: true
          },
          'Neon Shards': {
            url: 'resources/background3.mp3',
            volume: 0.28,
            loop: true
          },
          default: {
            url: 'resources/background1.mp3',
            volume: 0.23,
            loop: true
          }
        };

        pendingMusicTheme = 'Start Screen';

        function initAudioEngine(){
          if(audioCtx) return;
          var AudioCtx = window.AudioContext || window.webkitAudioContext;
          if(!AudioCtx) {
          console.warn('AudioContext not supported in this browser.');
            audioEnabled = false;
            return;
          }
          audioCtx = new AudioCtx();
          masterGain = audioCtx.createGain();
          masterGain.connect(audioCtx.destination);
          sfxGain = audioCtx.createGain();
          sfxGain.connect(masterGain);
          musicGain = audioCtx.createGain();
          musicGain.gain.value = 0;
          musicGain.connect(masterGain);
          applyAudioVolume();
        }

        function applyAudioVolume(){
          if(!masterGain) return;
          var target = audioEnabled ? audioVolume : 0;
          if(audioCtx){
            masterGain.gain.setTargetAtTime(target, audioCtx.currentTime, 0.08);
          } else {
            masterGain.gain.value = target;
          }
        }

        function setMasterVolume(value){
          audioVolume = Math.max(0, Math.min(1, value));
          applyAudioVolume();
        }

        function triggerTone(spec){
          if(!audioCtx || audioCtx.state === 'suspended') return;
          var osc = audioCtx.createOscillator();
          var gain = audioCtx.createGain();
          osc.type = spec.type || 'sine';
          osc.frequency.value = spec.freq;
          if(spec.detune) osc.detune.value = spec.detune;
          var now = audioCtx.currentTime;
          var attack = spec.attack !== undefined ? spec.attack : 0.02;
          var release = spec.release !== undefined ? spec.release : (spec.decay || 0.3);
          var peak = (spec.gain || 0.4);
          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.linearRampToValueAtTime(peak, now + attack);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + attack + release);
          if(spec.freqEnd){
            osc.frequency.exponentialRampToValueAtTime(spec.freqEnd, now + attack + release);
          }
          osc.connect(gain);
          gain.connect(spec.targetGain || sfxGain);
          osc.start(now);
          osc.stop(now + attack + release + 0.05);
          osc.onended = function(){
            try { osc.disconnect(); } catch(err){}
            try { gain.disconnect(); } catch(err){}
          };
          return { osc: osc, gain: gain };
        }

        function playSfx(key){
          if(!audioEnabled || !audioUnlocked) return;
          if(!audioCtx) return;
          var spec = sfxPresets[key];
          if(!spec) return;
          if(audioCtx.state === 'suspended'){
            audioCtx.resume().then(function(){ triggerTone(spec); }).catch(()=>{});
          } else {
            triggerTone(spec);
          }
        }

        function stopThemeMusic(){
          if(musicTimer){
            clearTimeout(musicTimer);
            musicTimer = null;
          }
          if(audioCtx && musicGain){
            try {
              musicGain.gain.cancelScheduledValues(audioCtx.currentTime);
              musicGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.4);
            } catch(err) {}
          }
          if(currentMusicSource){
            try { currentMusicSource.stop(); } catch(err) {}
            try { currentMusicSource.disconnect(); } catch(err) {}
            currentMusicSource = null;
          }
          if(musicNodes.length){
            var now = audioCtx ? audioCtx.currentTime : 0;
            musicNodes.forEach(function(node){
              try {
                node.gain.gain.cancelScheduledValues(now);
                node.gain.gain.setTargetAtTime(0.0001, now, 0.5);
                node.osc.stop(now + 0.8);
              } catch(err) {}
              if(node.lfo){
                try { node.lfo.stop(now + 0.8); } catch(err) {}
                try { node.lfo.disconnect(); } catch(err) {}
              }
              if(node.lfoGain){ try { node.lfoGain.disconnect(); } catch(err) {} }
              if(node.filter){ try { node.filter.disconnect(); } catch(err) {} }
              try { node.gain.disconnect(); } catch(err) {}
              try { node.osc.disconnect(); } catch(err) {}
            });
            musicNodes.length = 0;
          }
          currentMusicTheme = null;
          pendingMusicTheme = null;
        }

        function loadMusicBuffer(url){
          if(musicBuffers[url]) return Promise.resolve(musicBuffers[url]);
          if(musicTrackLoading[url]) return musicTrackLoading[url];
          if(!audioCtx) return Promise.reject(new Error('Audio context not ready'));
          var pending = fetch(url).then(function(response){
            if(!response.ok){
              throw new Error('Music request failed with status ' + response.status);
            }
            return response.arrayBuffer();
          }).then(function(data){
            return new Promise(function(resolve, reject){
              audioCtx.decodeAudioData(data, function(buffer){
                musicBuffers[url] = buffer;
                resolve(buffer);
              }, function(err){ reject(err); });
            });
          });
          musicTrackLoading[url] = pending.then(function(buffer){
            delete musicTrackLoading[url];
            return buffer;
          }, function(err){
            delete musicTrackLoading[url];
            throw err;
          });
          return musicTrackLoading[url];
        }

        function playProceduralMusic(themeName){
          var preset = musicPresets[themeName] || musicPresets.default;
          if(!preset || !preset.chords || !preset.chords.length){
            currentMusicTheme = themeName;
            pendingMusicTheme = null;
            return;
          }

          if(musicGain){
            var targetVol = preset.volume !== undefined ? preset.volume : 0.3;
            musicGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.6);
          }

          var chordIndex = 0;
          var waveform = preset.waveform || 'sine';
          var noteGain = preset.noteGain || 0.12;

          function playChord(){
            if(!audioCtx || audioCtx.state === 'closed'){ return; }
            if(musicTimer){ clearTimeout(musicTimer); musicTimer = null; }
            var data = preset.chords[chordIndex % preset.chords.length];
            chordIndex++;
            var now = audioCtx.currentTime;
            var attack = data.attack || 1.0;
            var release = data.release || 1.5;
            var duration = data.duration || 4.0;
            var pause = data.pause || 1.0;

            data.notes.forEach(function(freq){
              var osc = audioCtx.createOscillator();
              osc.type = waveform;
              osc.frequency.setValueAtTime(freq, now);
              var gainNode = audioCtx.createGain();
              gainNode.gain.setValueAtTime(0.0001, now);
              gainNode.gain.linearRampToValueAtTime(noteGain, now + attack);
              gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration + release);

              var filter = null;
              if(preset.filter){
                filter = audioCtx.createBiquadFilter();
                filter.type = preset.filter.type || 'lowpass';
                filter.frequency.value = preset.filter.freq || 900;
                filter.Q.value = preset.filter.Q || 1;
                osc.connect(filter);
                filter.connect(gainNode);
              } else {
                osc.connect(gainNode);
              }

              if(musicGain){
                gainNode.connect(musicGain);
              } else if(masterGain){
                gainNode.connect(masterGain);
              } else {
                gainNode.connect(audioCtx.destination);
              }

              var entry = { osc: osc, gain: gainNode, filter: filter };
              osc.onended = function(){
                try { osc.disconnect(); } catch(err){}
                try { gainNode.disconnect(); } catch(err){}
                if(filter){ try { filter.disconnect(); } catch(err){} }
                var i = musicNodes.indexOf(entry);
                if(i>=0) musicNodes.splice(i,1);
              };

              osc.start(now);
              osc.stop(now + duration + release + 0.2);
              musicNodes.push(entry);
            });

            musicTimer = setTimeout(playChord, (duration + pause) * 1000);
          }

          playChord();
          currentMusicTheme = themeName;
          pendingMusicTheme = null;
        }

        function startThemeMusic(themeName){
          if(!audioEnabled) return;
          if(!audioCtx){
            pendingMusicTheme = themeName;
            return;
          }
          if(audioCtx.state === 'suspended'){
            audioCtx.resume().then(function(){ startThemeMusic(themeName); }).catch(()=>{});
            return;
          }

          var track = musicTracks[themeName] || musicTracks.default;
          stopThemeMusic();
          currentMusicTheme = themeName;
          pendingMusicTheme = null;

          if(track && track.url){
            var targetVol = track.volume !== undefined ? track.volume : 0.3;
            if(musicGain){
              try {
                musicGain.gain.cancelScheduledValues(audioCtx.currentTime);
                musicGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
              } catch(err) {}
            }
            loadMusicBuffer(track.url).then(function(buffer){
              if(!audioCtx || audioCtx.state === 'closed') return;
              if(currentMusicTheme !== themeName) return;
              var source = audioCtx.createBufferSource();
              source.buffer = buffer;
              source.loop = track.loop !== false;
              if(track.loopStart !== undefined) source.loopStart = track.loopStart;
              if(track.loopEnd !== undefined) source.loopEnd = track.loopEnd;
              source.connect(musicGain || masterGain || audioCtx.destination);
              currentMusicSource = source;
              source.onended = function(){
                if(currentMusicSource === source) currentMusicSource = null;
              };
              var startAt = audioCtx.currentTime + 0.05;
              try {
                source.start(startAt);
              } catch(err){
                console.warn('Unable to start streamed music', err);
              }
              if(musicGain){
                musicGain.gain.setTargetAtTime(targetVol, startAt, 0.8);
              } else if(masterGain){
                masterGain.gain.setTargetAtTime(targetVol, startAt, 0.8);
              }
            }).catch(function(err){
              console.warn('Falling back to procedural music for theme', themeName, err);
              playProceduralMusic(themeName);
            });
            return;
          }

          playProceduralMusic(themeName);
        }

        function queueThemeMusic(theme){
          pendingMusicTheme = theme.name;
          if(audioUnlocked && audioCtx) startThemeMusic(theme.name);
        }

        function resumeMusic(){
          if(!audioEnabled) return;
          if(!audioUnlocked) return;
          if(!audioCtx){
            initAudioEngine();
            if(pendingMusicTheme) startThemeMusic(pendingMusicTheme);
            return;
          }
          audioCtx.resume().then(function(){
            if(pendingMusicTheme && pendingMusicTheme !== currentMusicTheme){
              startThemeMusic(pendingMusicTheme);
            }
          }).catch(function(err){ console.warn('Impossible de reprendre l\'audio', err); });
        }

        function pauseMusic(){
          if(audioCtx && audioCtx.state === 'running'){
            audioCtx.suspend().catch(()=>{});
          }
        }

        function ensureAudioReady(force){
          if(!audioEnabled) return;
          if(!audioCtx){
            initAudioEngine();
          }
          if(!audioCtx) return;
          if(audioCtx.state !== 'suspended'){
            if(!audioUnlocked) audioUnlocked = true;
            if(pendingMusicTheme && pendingMusicTheme !== currentMusicTheme){
              startThemeMusic(pendingMusicTheme);
            }
            return;
          }
          if(audioUnlocked && !force) return;
          audioCtx.resume().then(function(){
            audioUnlocked = true;
            if(pendingMusicTheme) startThemeMusic(pendingMusicTheme);
          }).catch(function(){
            audioUnlocked = false;
          });
        }

        function toggleAudio(){
          audioEnabled = !audioEnabled;
          var btn = document.getElementById('audio-btn');
          btn.textContent = 'Audio: ' + (audioEnabled ? 'on' : 'off');
          if(audioEnabled){
            ensureAudioReady();
            resumeMusic();
          } else {
            pauseMusic();
          }
          applyAudioVolume();
        }

        function enterMenuState(customMessage){
          stopThemeMusic();
          pendingMusicTheme = 'Start Screen';
          gameState = 'menu';
          var profile = getSelectedDifficulty();
          score = 0;
          level = profile.startLevel;
          lives = profile.lives;
          buildLevel({ preview: true });
          updateHUD();
          var prompt = customMessage || 'Select a level and paddle to start';
          showMessage(prompt);
          if(customMessage){
            setTimeout(function(){
              if(gameState === 'menu'){
                showMessage('Select a level and paddle to start');
              }
            }, 4200);
          }
          if(stageBanner){
            stageBanner.textContent = profile.name;
            stageBanner.style.opacity = 0.85;
          }
          if(audioEnabled){
            ensureAudioReady();
            resumeMusic();
          }
          updateDifficultyInfo();
        }

        THREE.Cache.enabled = true;

        var sceneThemes = [
          {
            name: 'Synthwave Nebula',
            clearColor: 0x0b1120,
            fog: { near: 45, far: 120 },
            ambientColor: 0x1e40af,
            ambientIntensity: 0.9,
            keyColor: 0xf97316,
            keyIntensity: 1.4,
            floorColor: 0x172554,
            modelUrl: 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf',
            modelScale: [4.2, 4.2, 4.2],
            modelPosition: { x: 12, y: 4.5, z: -6 },
            animation: 'spin',
            background: {
              sky: 'https://images.pexels.com/photos/713046/pexels-photo-713046.jpeg?auto=compress&cs=tinysrgb&w=2048',
              brick: 'https://images.pexels.com/photos/1457842/pexels-photo-1457842.jpeg?auto=compress&cs=tinysrgb&w=1024'
            }
          },
          {
            name: 'Cosmic Garden',
            clearColor: 0x02140c,
            fog: { near: 35, far: 90 },
            ambientColor: 0x16a34a,
            ambientIntensity: 0.8,
            keyColor: 0x4ade80,
            keyIntensity: 1.2,
            floorColor: 0x0f5132,
            modelUrl: 'https://threejs.org/examples/models/gltf/Flamingo.glb',
            modelScale: [0.06, 0.06, 0.06],
            modelPosition: { x: -14, y: 5.5, z: -8 },
            animation: 'float',
            background: {
              sky: 'https://images.pexels.com/photos/1938347/pexels-photo-1938347.jpeg?auto=compress&cs=tinysrgb&w=2048',
              brick: 'https://images.pexels.com/photos/259915/pexels-photo-259915.jpeg?auto=compress&cs=tinysrgb&w=1024'
            }
          },
          {
            name: 'Orbital Station',
            clearColor: 0x0a0a0f,
            fog: { near: 60, far: 160 },
            ambientColor: 0x64748b,
            ambientIntensity: 0.85,
            keyColor: 0x38bdf8,
            keyIntensity: 1.3,
            floorColor: 0x1f2937,
            modelUrl: 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            modelScale: [1.4, 1.4, 1.4],
            modelPosition: { x: 11, y: 3.2, z: -7 },
            animation: 'hover',
            animationClips: ['Dance', 'Jump', 'Wave', 'Walk'],
            animationPause: 700,
            animationFade: 0.4,
            background: {
              sky: 'https://images.pexels.com/photos/237630/pexels-photo-237630.jpeg?auto=compress&cs=tinysrgb&w=2048',
              brick: 'https://images.pexels.com/photos/220326/pexels-photo-220326.jpeg?auto=compress&cs=tinysrgb&w=1024'
            }
          },
          {
            name: 'Aurora Peaks',
            clearColor: 0x0d1627,
            fog: { near: 65, far: 200 },
            ambientColor: 0xb6d7ff,
            ambientIntensity: 0.9,
            keyColor: 0x7dd3fc,
            keyIntensity: 1.25,
            floorColor: 0x10253a,
            modelUrl: 'https://threejs.org/examples/models/gltf/Fox/glTF/Fox.gltf',
            modelScale: [0.05, 0.05, 0.05],
            modelPosition: { x: -6, y: 2.6, z: -5 },
            animation: 'float',
            background: {
              sky: 'https://images.pexels.com/photos/761993/pexels-photo-761993.jpeg?auto=compress&cs=tinysrgb&w=2048',
              brick: 'https://images.pexels.com/photos/1450082/pexels-photo-1450082.jpeg?auto=compress&cs=tinysrgb&w=1024'
            }
          },
          {
            name: 'Desert Mirage',
            clearColor: 0x2b1703,
            fog: { near: 70, far: 210 },
            ambientColor: 0xfacc15,
            ambientIntensity: 0.7,
            keyColor: 0xff8a4c,
            keyIntensity: 1.4,
            floorColor: 0x8c4b16,
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb',
            modelScale: [1.6, 1.6, 1.6],
            modelPosition: { x: 9, y: 1.4, z: -6 },
            animation: 'hover',
            animationClips: ['Walk', 'Trot', 'Gallop'],
            animationPause: 1200,
            animationFade: 0.6,
            background: {
              sky: 'https://images.pexels.com/photos/248797/pexels-photo-248797.jpeg?auto=compress&cs=tinysrgb&w=2048',
              brick: 'https://images.pexels.com/photos/1005644/pexels-photo-1005644.jpeg?auto=compress&cs=tinysrgb&w=1024'
            }
          },
          {
            name: 'Neon Shards',
            clearColor: 0x03020a,
            fog: { near: 80, far: 240 },
            ambientColor: 0x1f27ff,
            ambientIntensity: 0.8,
            keyColor: 0xff4d94,
            keyIntensity: 1.45,
            floorColor: 0x111332,
            modelUrl: 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            modelScale: [1.1, 1.1, 1.1],
            modelPosition: { x: -9, y: 2.8, z: -5 },
            animation: 'hover',
            animationClips: ['Dance', 'Wave'],
            animationPause: 900,
            animationFade: 0.5,
            background: {
              sky: 'https://images.pexels.com/photos/3573382/pexels-photo-3573382.jpeg?auto=compress&cs=tinysrgb&w=2048',
              brick: 'https://images.pexels.com/photos/373912/pexels-photo-373912.jpeg?auto=compress&cs=tinysrgb&w=1024'
            }
          }
        ];

        function hslColor(h, s, l){
          var color = new THREE.Color();
          color.setHSL(h, s, l);
          return color;
        }

        function updatePaddleHitRadius(){
          var bbox = new THREE.Box3().setFromObject(paddle);
          var size = bbox.getSize(new THREE.Vector3());
          if(size.x) paddleHitRadius = Math.max(2.6, size.x / 2);
        }

        function enablePlaceholderPaddle(){
          paddlePlaceholderParts.forEach(function(mesh){ mesh.visible = true; });
          updatePaddleHitRadius();
        }

        function loadPaddleModel(){
          // Decorative booster fins
          var finMaterial = new THREE.MeshStandardMaterial({ color: 0x60a5fa, emissive: 0x2563eb, emissiveIntensity: 0.4, metalness: 0.6, roughness: 0.22 });
          for(var i=-1;i<=1;i+=2){
            var fin = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.4, 16), finMaterial);
            fin.rotation.z = Math.PI/2;
            fin.position.set(i*2.9, 0, -0.6);
            paddle.add(fin);
            paddlePlaceholderParts.push(fin);
          }
          enablePlaceholderPaddle();
        }

        function clampPaddlePosition(){
          var limit = playfieldHalfWidth - paddleHitRadius;
          paddle.position.x = THREE.Math.clamp(paddle.position.x, -limit, limit);
          paddleTargetX = THREE.Math.clamp(paddleTargetX, -limit, limit);
        }

        var levelLayouts = [
          function classicLayout(currentLevel, addBlock){
            var width = Math.min(14 + Math.floor(currentLevel * 0.8), 22);
            var height = Math.min(6 + Math.floor(currentLevel / 2), 9);
            var spacing = 1.35;
            for (var i = -Math.floor(width/2); i < Math.ceil(width/2); i++) {
              for (var j = 0; j < height; j++) {
                var hue = 0.55 + (j/height) * 0.15;
                addBlock(i * spacing, j * spacing + 2.2, hslColor(hue % 1, 0.65, 0.52));
              }
            }
          },
          function waveLayout(currentLevel, addBlock){
            var columns = 14 + currentLevel * 2;
            for(var k=0; k<columns; k++){
              var x = (k - columns/2) * 1.5;
              for(var row=0; row<3 + Math.floor(currentLevel/2); row++){
                var y = row * 1.6 + Math.sin((k / 2) + currentLevel) * 1.4 + 3;
                var hue = 0.05 + (k / columns) * 0.25;
                addBlock(x, y, hslColor(hue % 1, 0.7, 0.5));
              }
            }
          },
          function pyramidLayout(currentLevel, addBlock){
            var rows = Math.min(7 + Math.floor(currentLevel / 2), 10);
            var spacing = 1.5;
            for(var row=0; row<rows; row++){
              var blocksInRow = rows - row + 2;
              for(var col=0; col<blocksInRow; col++){
                var x = (col - blocksInRow / 2) * spacing;
                var y = row * spacing + 2.5;
                var hue = 0.7 + (row / rows) * 0.1;
                addBlock(x, y, hslColor(hue % 1, 0.5, 0.58));
              }
            }
          }
        ];

        function buildLevel(options){
          options = options || {};
          while (brickGroup.children.length) brickGroup.remove(brickGroup.children[0]);
          blocks.length = 0;
          var theme = sceneThemes[(level - 1) % sceneThemes.length];
          var brickTexture = theme && theme.background ? getBrickTexture(theme.background.brick) : null;

          var addBlock = function(x, y, color){
            var baseColor = color && color.isColor ? color.clone() : new THREE.Color(color || 0xffffff);
            var emissiveColor = baseColor.clone().multiplyScalar(0.18);
            baseColor.offsetHSL(0, 0, (Math.random() - 0.5) * 0.05);
            var blockMaterial = new THREE.MeshStandardMaterial({
              color: baseColor,
              metalness: 0.34,
              roughness: 0.46,
              emissive: emissiveColor
            });
            if(brickTexture){
              blockMaterial.map = brickTexture;
              blockMaterial.needsUpdate = true;
            }
            var block = new THREE.Mesh(blockGeometry, blockMaterial);
            block.castShadow = true;
            block.receiveShadow = true;
            block.position.set(x, y, 0);
            brickGroup.add(block);
            blocks.push(block);
          };

          var layoutIndex = (level - 1) % levelLayouts.length;
          levelLayouts[layoutIndex](level, addBlock);
          applyTheme(level, options);
        }

        function applyTheme(nextLevel, options){
          options = options || {};
          var theme = sceneThemes[(nextLevel - 1) % sceneThemes.length];
          currentTheme = theme;
          currentThemeBaseY = theme.modelPosition.y;

          renderer.setClearColor(theme.clearColor);
          if(theme.fog){
            scene.fog = new THREE.Fog(new THREE.Color(theme.clearColor), theme.fog.near, theme.fog.far);
          } else {
            scene.fog = null;
          }

          ambientLight.color.setHex(theme.ambientColor);
          ambientLight.intensity = theme.ambientIntensity;
          light.color.setHex(theme.keyColor);
          light.intensity = theme.keyIntensity;

          if(currentThemeMixer){
            currentThemeMixer.stopAllAction();
            currentThemeMixer = null;
          }
          stopThemeAnimationCycle();
          currentThemeModel = null;
          while (themeGroup.children.length) themeGroup.remove(themeGroup.children[0]);
          var floorMaterial = new THREE.MeshPhongMaterial({ color: theme.floorColor || 0x222c4a, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
          var floor = new THREE.Mesh(new THREE.PlaneGeometry(160, 160), floorMaterial);
          floor.rotation.x = -Math.PI/2;
          floor.position.set(0, -15.2, -12);
          themeGroup.add(floor);

          var wallMaterial = new THREE.MeshPhongMaterial({ color: 0x1b263b, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
          var wall = new THREE.Mesh(new THREE.PlaneGeometry(160, 110), wallMaterial);
          wall.position.set(0, 25, -40);
          themeGroup.add(wall);

          wall.visible = false;
          floor.material.map = null;
          floor.material.color.set(theme.floorColor || 0x222c4a);
          floor.material.opacity = 0.92;
          floor.material.needsUpdate = true;

          setSkyTexture(theme);

          loadThemeModel(theme);
          if(!options.preview){
            queueThemeMusic(theme);
          } else {
            pendingMusicTheme = 'Start Screen';
          }
          setSceneBanner(theme.name);
        }

        function loadThemeModel(theme){
          getGLTFLoader(function(loader){
            if(!loader){
              console.warn('3D theme loading disabled (GLTFLoader missing).');
              return;
            }
            loader.load(theme.modelUrl, function(gltf){
              if(currentTheme !== theme) return;
              currentThemeModel = gltf.scene;
              currentThemeModel.scale.set(theme.modelScale[0], theme.modelScale[1], theme.modelScale[2]);
              currentThemeModel.position.set(theme.modelPosition.x, theme.modelPosition.y, theme.modelPosition.z);
              currentThemeModel.traverse(function(node){ if(node.isMesh){ node.receiveShadow = false; node.castShadow = false; } });
              themeGroup.add(currentThemeModel);
              currentThemeBaseY = theme.modelPosition.y;
              if(gltf.animations && gltf.animations.length){
                currentThemeMixer = new THREE.AnimationMixer(currentThemeModel);
                setupThemeAnimations(theme, gltf);
              } else {
                currentThemeMixer = null;
                stopThemeAnimationCycle();
              }
            }, undefined, function(err){
              currentThemeModel = null;
              currentThemeMixer = null;
              stopThemeAnimationCycle();
              console.warn('Unable to load theme model', err);
            });
          });
        }

        function stopThemeAnimationCycle(){
          if(currentThemeAnimation){
            if(currentThemeAnimation.timeout) clearTimeout(currentThemeAnimation.timeout);
            if(currentThemeAnimation.currentAction) currentThemeAnimation.currentAction.stop();
          }
          currentThemeAnimation = null;
        }

        function setupThemeAnimations(theme, gltf){
          stopThemeAnimationCycle();
          if(!currentThemeMixer) return;

          var clips = [];
          if(Array.isArray(theme.animationClips) && theme.animationClips.length){
            theme.animationClips.forEach(function(name){
              var clip = THREE.AnimationClip.findByName(gltf.animations, name);
              if(clip) clips.push(clip);
            });
          }
          if(!clips.length) clips = gltf.animations.slice();
          if(!clips.length) return;

          var actions = clips.map(function(clip){
            var action = currentThemeMixer.clipAction(clip);
            action.clampWhenFinished = true;
            action.setLoop(THREE.LoopOnce, 1);
            action.enabled = true;
            return { clip: clip, action: action };
          });

          currentThemeAnimation = {
            actions: actions,
            index: -1,
            fade: theme.animationFade !== undefined ? theme.animationFade : 0.6,
            pause: theme.animationPause !== undefined ? theme.animationPause : 1000,
            timeout: null,
            currentAction: null
          };

          cycleThemeAnimation();
        }

        function cycleThemeAnimation(){
          if(!currentThemeAnimation || !currentThemeAnimation.actions.length) return;
          var state = currentThemeAnimation;
          state.index = (state.index + 1) % state.actions.length;
          var entry = state.actions[state.index];
          var action = entry.action;

          if(state.currentAction && state.currentAction !== action){
            state.currentAction.fadeOut(state.fade);
          }

          action.reset();
          action.fadeIn(state.fade).play();
          state.currentAction = action;

          var duration = Math.max(0.5, entry.clip.duration || 0.5) * 1000;
          if(state.timeout) clearTimeout(state.timeout);
          state.timeout = setTimeout(cycleThemeAnimation, duration + state.pause);
        }

        function animateThemeModel(delta){
          if(currentThemeMixer) currentThemeMixer.update(delta);
          if(!currentThemeModel || !currentTheme || currentThemeMixer) return;
          var time = Date.now() * 0.001;
          if(currentTheme.animation === 'spin'){
            currentThemeModel.rotation.y += 0.003;
          } else if(currentTheme.animation === 'float'){
            currentThemeModel.rotation.y += 0.0025;
            currentThemeModel.position.y = currentThemeBaseY + Math.sin(time * 0.6) * 0.45;
          } else if(currentTheme.animation === 'hover'){
            currentThemeModel.rotation.y = Math.sin(time * 1.1) * 0.18;
            currentThemeModel.position.y = currentThemeBaseY + Math.sin(time * 1.6) * 0.24;
          }
        }
        // Power-up spawn: sphere that falls; collision with ball activates effect
        function spawnPowerUp(){
          var types = ['expand', 'life', 'score'];
          var type = types[Math.floor(Math.random() * types.length)];
          var palette = {
            expand: { color: 0xffd54f, emissive: 0xffb300, light: 0xffc566 },
            life: { color: 0x4ade80, emissive: 0x22c55e, light: 0x7ef4a5 },
            score: { color: 0x60a5fa, emissive: 0x3b82f6, light: 0x9ccfff }
          };
          var look = palette[type];

          var container = new THREE.Group();
          container.position.set((Math.random()*40)-20, 12, 0);

          var core = new THREE.Mesh(
            new THREE.IcosahedronGeometry(0.55, 0),
            new THREE.MeshStandardMaterial({
              color: look.color,
              emissive: look.emissive,
              emissiveIntensity: 0.75,
              metalness: 0.2,
              roughness: 0.35
            })
          );
          container.add(core);

          var halo = new THREE.Mesh(
            new THREE.SphereGeometry(0.85, 24, 18),
            new THREE.MeshBasicMaterial({ color: look.light, transparent: true, opacity: 0.22 })
          );
          container.add(halo);

          var light = new THREE.PointLight(look.light, 1.1, 10);
          light.position.set(0, 0, 0.4);
          container.add(light);

          container.userData = { type: type, core: core, halo: halo, light: light };
          scene.add(container);
          powerUps.push(container);
          // auto-remove after 12s
          setTimeout(()=>{
            var idx = powerUps.indexOf(container);
            if(idx>=0){
              scene.remove(container);
              powerUps.splice(idx,1);
            }
          }, 12000);
        }
        // spawn periodically when playing
        setInterval(()=>{ if(gameState==='playing' && Math.random()<0.6) spawnPowerUp(); }, 10000);

        // Input: keyboard + mouse
        var keyState = { left: false, right: false };
        document.addEventListener("keydown", function(event) {
          if(event.code==='Space'){
            if(gameState==='playing') { gameState='paused'; pauseMusic(); showMessage('Paused'); }
            else if(gameState==='paused'){ gameState='playing'; document.getElementById('message').style.display='none'; resumeMusic(); }
            updateAbilityUI();
            return;
          }
          if (event.code === "ArrowLeft" || event.code === 'KeyA'){ keyState.left = true; mouseControlActive = false; }
          else if (event.code === "ArrowRight" || event.code === 'KeyD'){ keyState.right = true; mouseControlActive = false; }
        });
        document.addEventListener("keyup", function(event){
          if (event.code === "ArrowLeft" || event.code === 'KeyA'){ keyState.left = false; }
          else if (event.code === "ArrowRight" || event.code === 'KeyD'){ keyState.right = false; }
          else if (event.code === 'KeyF'){ magicKeyPressed = false; }
          if(!keyState.left && !keyState.right){
            paddleTargetX = mouseControlActive ? mouseTargetX : paddle.position.x;
          }
        });
        var magicKeyPressed = false;
        document.addEventListener('keydown', function(event){
          if(event.code === 'KeyF' && !magicKeyPressed){
            magicKeyPressed = true;
            activateMagicPower();
          }
        });
        window.addEventListener('mousemove', function(e){
          // convert screen x to world x (approx)
          var ratio = (e.clientX / window.innerWidth) * 2 - 1;
          var limit = playfieldHalfWidth - paddleHitRadius;
          mouseTargetX = THREE.Math.clamp(ratio * playfieldHalfWidth, -limit, limit);
          mouseControlActive = true;
          paddleTargetX = mouseTargetX;
        });

        // Buttons
        document.getElementById('start-btn').addEventListener('click', function(){ startGame(); });
        document.getElementById('pause-btn').addEventListener('click', function(){
          if(gameState==='playing'){ gameState='paused'; pauseMusic(); showMessage('Paused'); }
          else if(gameState==='paused'){ gameState='playing'; document.getElementById('message').style.display='none'; resumeMusic(); }
          updateAbilityUI();
        });
        document.getElementById('restart-btn').addEventListener('click', function(){
          window.location.href = window.location.origin + window.location.pathname;
        });
        document.getElementById('audio-btn').addEventListener('click', toggleAudio);
        var volumeSlider = document.getElementById('volume-range');
        volumeSlider.value = Math.round(audioVolume * 100);
        volumeSlider.addEventListener('input', function(e){
          if(!audioUnlocked && audioEnabled) ensureAudioReady();
          setMasterVolume((parseInt(e.target.value, 10) || 0) / 100);
        });

        var levelModal = document.getElementById('level-select-modal');
        var levelCards = Array.prototype.slice.call(document.querySelectorAll('.level-card'));
        var levelConfirm = document.getElementById('level-confirm');
        var levelDetails = document.getElementById('level-details');
        var levelOpenBtn = document.getElementById('level-open-btn');
        var paddleOpenBtn = document.getElementById('paddle-open-btn');
        var difficultyInfoEl = document.getElementById('difficulty-info');
        var pendingDifficultyKey = selectedDifficultyKey;

        function describeDifficulty(profile){
          return profile.name + ' — ' + profile.description;
        }

        function updateDifficultyInfo(){
          var profile = getSelectedDifficulty();
          if(difficultyInfoEl) difficultyInfoEl.textContent = describeDifficulty(profile);
          if(levelOpenBtn) levelOpenBtn.textContent = 'Level: ' + profile.name;
          updatePaddleButtonLabel();
        }

        function refreshLevelCards(){
          levelCards.forEach(function(card){
            var key = card.getAttribute('data-key');
            card.classList.toggle('active', key === pendingDifficultyKey);
          });
          var profile = difficultyProfiles[pendingDifficultyKey] || getSelectedDifficulty();
          if(levelDetails) levelDetails.textContent = describeDifficulty(profile);
        }

        function openLevelModal(){
          pendingDifficultyKey = selectedDifficultyKey;
          refreshLevelCards();
          levelModal.classList.remove('hidden');
        }

        function closeLevelModal(){
          levelModal.classList.add('hidden');
        }

        function applyDifficultySelection(key){
          if(!difficultyProfiles[key]) return;
          selectedDifficultyKey = key;
          var profile = difficultyProfiles[key];
          updateDifficultyInfo();
          if(gameState === 'menu'){
            if(stageBanner) stageBanner.textContent = profile.name;
            level = profile.startLevel;
            lives = profile.lives;
            updateHUD();
            buildLevel({ preview: true });
          }
          if(gameState === 'menu' && audioEnabled && audioUnlocked){
            pendingMusicTheme = 'Start Screen';
            resumeMusic();
          }
        }

        levelCards.forEach(function(card){
          card.addEventListener('click', function(){
            pendingDifficultyKey = card.getAttribute('data-key');
            refreshLevelCards();
          });
        });

        if(levelConfirm){
          levelConfirm.addEventListener('click', function(){
            applyDifficultySelection(pendingDifficultyKey);
            closeLevelModal();
          });
        }

        if(levelOpenBtn){
          levelOpenBtn.addEventListener('click', function(){
            openLevelModal();
          });
        }

        function highlightSelectedPaddleCard(){
          paddleCards.forEach(function(card){
            card.classList.toggle('active', card.getAttribute('data-key') === selectedPaddleKey);
          });
          if(selectedPaddleKey){
            selectConfirm.disabled = false;
            selectConfirm.setAttribute('data-key', selectedPaddleKey);
            var profile = paddleProfiles[selectedPaddleKey];
            if(profile){
              paddleDetails.textContent = profile.description + ' — ability: ' + profile.ability.name + ' (press F)';
            }
          }
        }

        function updatePaddleButtonLabel(){
          if(!paddleOpenBtn) return;
          if(selectedPaddleProfile){
            paddleOpenBtn.textContent = 'Paddle: ' + selectedPaddleProfile.name;
          } else {
            paddleOpenBtn.textContent = 'Select Paddle';
          }
        }

        if(paddleOpenBtn){
          paddleOpenBtn.addEventListener('click', function(){
            highlightSelectedPaddleCard();
            openSelectionModal();
          });
        }

        if(levelModal){
          levelModal.addEventListener('click', function(evt){
            if(evt.target === levelModal){
              closeLevelModal();
            }
          });
        }

        updateDifficultyInfo();
        updatePaddleButtonLabel();

        function startGame(){
          if(!selectedPaddleProfile){
            openSelectionModal();
            showMessage('Choose a paddle to get started', 1800);
            return;
          }
          var difficulty = getSelectedDifficulty();
          stopThemeMusic();
          ensureAudioReady();
          playSfx('levelUp');
          score = 0;
          level = difficulty.startLevel;
          lives = difficulty.lives;
          totalBlocksDestroyed = 0;
          resetCombo();
          resetQuest();
          while(powerUps.length){ var extra = powerUps.pop(); scene.remove(extra); }
          baseBallSpeed = defaultBaseBallSpeed * (difficulty.speedMultiplier || 1);
          maxBallSpeed = defaultMaxBallSpeed * (difficulty.maxSpeedMultiplier || 1);
          ballSpeedGrowth = defaultBallSpeedGrowth * (difficulty.growthMultiplier || 1);
          ballSpeed = baseBallSpeed;
          buildLevel();
          resetBallPosition();
          paddle.position.x = 0;
          paddleTargetX = 0;
          paddleVelocity = 0;
          clampPaddlePosition();
          resetAbilityState();
          updateAbilityUI();
          gameState='playing';
          updateHUD();
          document.getElementById('message').style.display='none';
          resumeMusic();
        }

        // Achievements helper
        function checkAchievements(){
          if(score >= 100 && !achievements['Score 100']){ achievements['Score 100'] = true; showMessage('Achievement: 100 points!', 2000); }
          if(level >= 3 && !achievements['Level 3']){ achievements['Level 3'] = true; showMessage('Achievement: level 3 reached!', 2000); }
          if(comboMultiplier() >= 3 && !achievements['Combo x3']){ achievements['Combo x3'] = true; showMessage('Achievement: combo x3!', 2000); }
          if(totalBlocksDestroyed >= 50 && !achievements['50 bricks']){ achievements['50 bricks'] = true; showMessage('Achievement: 50 bricks destroyed!', 2000); }
          if(quest && quest.completed && !achievements['Quest']){ achievements['Quest'] = true; showMessage('Achievement: quest completed!', 2000); }
          updateHUD();
        }

        function destroyBlockAtIndex(index, options){
          if(index < 0 || index >= blocks.length) return null;
          options = options || {};
          var block = blocks[index];
          var hitPosition = block.position.clone();
          brickGroup.remove(block);
          blocks.splice(index, 1);
          if(options.playSound !== false) playSfx('block');
          boostCombo();
          var gainedBase = Math.floor(12 * comboMultiplier());
          var scoreMultiplier = options.scoreMultiplier !== undefined ? options.scoreMultiplier : 1;
          var gained = Math.max(4, Math.floor(gainedBase * scoreMultiplier));
          score += gained;
          totalBlocksDestroyed++;
          if(quest && !quest.completed) quest.progress++;
          if(score > bestScore) saveBestScore(score);
          updateHUD();
          tryCompleteQuest();
          checkAchievements();
          var fireTriggered = !!(abilityState.fireballActive && options.fireBurst && !options.disableFireChain);
          spawnBrickBurst(hitPosition, fireTriggered);
          startBlockFade(block, fireTriggered);
          if(fireTriggered){
            spawnWizzEffect(hitPosition, abilityState.fireballRadius || 2.5, true);
          }

          if(fireTriggered && options.allowIgnite !== false){
            igniteNearbyBlocks(hitPosition, abilityState.fireballRadius || 2.8);
          }

          if(blocks.length === 0 && options.skipLevelCheck !== true){
            handleLevelCleared();
          }

          return hitPosition;
        }

        function igniteNearbyBlocks(center, radius){
          if(!abilityState.fireballActive) return;
          radius = radius || 2.8;
          var radiusSq = radius * radius;
          var candidates = [];
          for(var idx = 0; idx < blocks.length; idx++){
            var candidate = blocks[idx];
            var distSq = candidate.position.distanceToSquared(center);
            if(distSq <= radiusSq){
              candidates.push({ block: candidate, dist: distSq });
            }
          }
          candidates.sort(function(a, b){ return a.dist - b.dist; });
          var destroyed = 0;
          for(var i=0;i<candidates.length && destroyed < 3;i++){
            var entry = candidates[i];
            var index = blocks.indexOf(entry.block);
            if(index !== -1){
              destroyBlockAtIndex(index, { allowIgnite: false, playSound: false, scoreMultiplier: 0.75, skipLevelCheck: true, fireBurst: true, disableFireChain: true });
              destroyed++;
            }
          }
          if(destroyed && blocks.length === 0){
            handleLevelCleared();
          }
        }

        function handleLevelCleared(){
          var difficulty = getSelectedDifficulty();
          level++;
          resetCombo();
          while(powerUps.length){ var dropped = powerUps.pop(); scene.remove(dropped); }
          buildLevel();
          var baseSeed = defaultBaseBallSpeed * (difficulty.speedMultiplier || 1);
          var levelsCompleted = Math.max(0, level - (difficulty.startLevel || 1));
          baseBallSpeed = Math.min(baseSeed + levelsCompleted * ballSpeedGrowth, maxBallSpeed * 0.85);
          ballSpeed = baseBallSpeed;
          resetBallPosition();
          var themeLabel = currentTheme ? currentTheme.name : 'Level';
          showMessage('Level ' + level + ' - ' + themeLabel, 1800);
          playSfx('levelUp');
        }

        function startBlockFade(mesh, fireMode){
          if(!mesh) return;
          var fadeMaterial = mesh.material;
          if(fadeMaterial && !fadeMaterial.transparent){
            mesh.material = fadeMaterial.clone();
            mesh.material.transparent = true;
          }
          if(mesh.material){
            mesh.material.opacity = 1;
          }
          mesh.scale.set(1,1,1);
          scene.add(mesh);
          fadingBlocks.push({ mesh: mesh, life: fireMode ? 0.45 : 0.35, age: 0 });
        }

        function spawnWizzEffect(position, radius, fireMode){
          radius = radius || 2.4;
          var count = fireMode ? 80 : 48;
          var geometry = new THREE.BufferGeometry();
          var positions = new Float32Array(count * 3);
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: fireMode ? 0.48 : 0.36,
            sizeAttenuation: true,
            map: getParticleTexture(fireMode ? '#ff9b6a' : '#7dd3fc'),
            transparent: true,
            opacity: 0.92,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            alphaTest: 0.01
          });
          var points = new THREE.Points(geometry, material);
          points.position.copy(position);
          points.frustumCulled = false;
          var angles = new Array(count);
          for(var i=0;i<count;i++){
            var angle = (i / count) * Math.PI * 2;
            angles[i] = angle;
            var x = Math.cos(angle) * radius;
            var z = Math.sin(angle) * radius;
            var y = Math.sin(angle * 2.2) * (fireMode ? 0.8 : 0.4);
            positions[i*3] = x;
            positions[i*3 + 1] = y;
            positions[i*3 + 2] = z;
          }
          geometry.attributes.position.needsUpdate = true;
          scene.add(points);
          wizzEffects.push({
            points: points,
            angles: angles,
            radius: radius,
            wave: fireMode ? 0.8 : 0.4,
            spin: fireMode ? 6.5 : 4.2,
            life: fireMode ? 0.55 : 0.45,
            age: 0,
            count: count
          });
        }

        function spawnBrickBurst(position, fireMode){
          if(!position) return;
          var count = fireMode ? 72 : 42;
          var positions = new Float32Array(count * 3);
          var velocities = new Float32Array(count * 3);
          for(var i=0;i<count;i++){
            var theta = Math.random() * Math.PI * 2;
            var speed = fireMode ? 14 + Math.random() * 10 : 10 + Math.random() * 6;
            var uplift = fireMode ? 6 + Math.random() * 4 : 3 + Math.random() * 2;
            velocities[i*3] = Math.cos(theta) * speed;
            velocities[i*3 + 1] = uplift;
            velocities[i*3 + 2] = Math.sin(theta) * speed * 0.6;
            positions[i*3] = 0;
            positions[i*3 + 1] = 0;
            positions[i*3 + 2] = 0;
          }
          var geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: fireMode ? 0.42 : 0.32,
            sizeAttenuation: true,
            map: getParticleTexture(fireMode ? '#ff924d' : '#8fd6ff'),
            transparent: true,
            opacity: fireMode ? 0.95 : 0.82,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            alphaTest: 0.01
          });
          var points = new THREE.Points(geometry, material);
          points.position.copy(position);
          points.frustumCulled = false;
          scene.add(points);
          brickBursts.push({
            points: points,
            positions: positions,
            velocities: velocities,
            life: fireMode ? 0.55 : 0.4,
            age: 0,
            fire: fireMode
          });
          if(fireMode){
            spawnWizzEffect(position, radius, true);
          }
        }

        // Collision + game logic updates
        function checkForCollisions(){
          if(gameState!=='playing') return;

          // Walls
          if (ball.position.x < -playfieldHalfWidth || ball.position.x > playfieldHalfWidth){
            ballDirection.x *= -1;
            ball.position.x = THREE.Math.clamp(ball.position.x, -playfieldHalfWidth, playfieldHalfWidth);
            stabiliseBallDirection();
          }

          if(abilityState.iceWallActive && ballDirection.y < 0 && ball.position.y <= iceWallY + 0.6){
            ballDirection.y = Math.abs(ballDirection.y);
            ball.position.y = iceWallY + 0.65;
            stabiliseBallDirection(0.28);
            playSfx('powerup');
          }

          if (ball.position.y < -13) {
            lives--;
            playSfx('lifeLost');
            saveBestScore(score);
            resetCombo();
            updateHUD();
            if(lives<=0){
              playSfx('gameOver');
              enterMenuState('Game Over - score ' + score);
              return;
            }
            resetBallPosition();
          }

          if (ball.position.y > 15){
            ballDirection.y *= -1;
            ball.position.y = 15;
            stabiliseBallDirection();
          }

          // Paddle collision
          var paddleHalfWidth = paddleHitRadius;
          var paddleHeight = 1.2;
          if (ball.position.y <= paddle.position.y + paddleHeight && ball.position.y >= paddle.position.y - paddleHeight) {
            if (ball.position.x > paddle.position.x - paddleHalfWidth && ball.position.x < paddle.position.x + paddleHalfWidth) {
              var relative = (ball.position.x - paddle.position.x) / paddleHalfWidth;
              relative = THREE.Math.clamp(relative, -1, 1);
              var bounceAngle = relative * THREE.Math.degToRad(70);
              var newDir = new THREE.Vector3(Math.sin(bounceAngle), Math.cos(bounceAngle), 0);
              if(newDir.y <= 0) newDir.y = Math.abs(newDir.y) || 0.5;
              ballDirection.copy(newDir.normalize());
              ball.position.y = paddle.position.y + paddleHeight + 0.1;
              accelerateBall(1 + (Math.abs(relative) * 0.12));
              playSfx('paddle');
              stabiliseBallDirection(0.32);
            }
          }

          // Blocks collision (simple distance test)
          for (var i = 0; i < blocks.length; i++) {
            var block = blocks[i];
            if (block.position.distanceTo(ball.position) < 1.2) {
              var diffX = Math.abs(ball.position.x - block.position.x);
              var diffY = Math.abs(ball.position.y - block.position.y);
              var unstoppable = abilityState.fireballActive;
              if(!unstoppable){
                if(diffX > diffY){
                  ballDirection.x *= -1;
                } else {
                  ballDirection.y *= -1;
                }
                stabiliseBallDirection();
                accelerateBall(1.02);
              } else {
                accelerateBall(1.01);
              }
              destroyBlockAtIndex(i, { allowIgnite: true, fireBurst: abilityState.fireballActive });
              i--;
            }
          }

          // Power-ups falling
          for(var p=0;p<powerUps.length;p++){
            var up = powerUps[p];
            up.position.y -= 0.05;
            up.rotation.y += 0.03;
            if(up.userData && up.userData.halo){
              var halo = up.userData.halo;
              halo.material.opacity = 0.18 + 0.07 * Math.sin(Date.now()*0.002 + p);
            }
            var collectedByBall = up.position.distanceTo(ball.position) < 1.2;
            var collectedByPaddle = false;
            if(!collectedByBall){
              var dx = Math.abs(up.position.x - paddle.position.x);
              var dy = Math.abs(up.position.y - paddle.position.y);
              if(dx <= paddleHitRadius + 1 && dy <= 2.2){
                collectedByPaddle = true;
              }
            }
            if(collectedByBall || collectedByPaddle){
              if(up.userData.type==='expand'){
                paddle.scale.x = 2;
                updatePaddleHitRadius();
                setTimeout(()=>{ paddle.scale.x = 1; updatePaddleHitRadius(); }, 8000);
              showMessage('Power-up: Paddle expanded', 1500);
              playSfx('powerup');
            } else if(up.userData.type==='life'){
                lives++; updateHUD(); showMessage('Power-up: Extra life', 1200);
                playSfx('powerup');
              } else if(up.userData.type==='score'){
                score += 100;
                saveBestScore(score);
                updateHUD();
                showMessage('Power-up: +100 points', 1200);
                playSfx('powerup');
              }
              scene.remove(up);
              powerUps.splice(p,1); p--;
            }
          }
        }

        function lightMouvement(){
          light.position.x = ball.position.x;
          light.position.y = ball.position.y;
        }

        function updateCameraPosition(){
          var focusY = THREE.Math.clamp(ball.position.y * 0.25, -2, 4);
          var focusX = THREE.Math.clamp(ball.position.x * 0.12, -2.8, 2.8);
          var desiredLook = tempVec1.set(focusX, focusY, 0);

          target_view.lerp(desiredLook, 0.04);

          var desiredCameraPos = tempVec2.set(
            cameraBasePosition.x + target_view.x * 0.08,
            cameraBasePosition.y + target_view.y * 0.12,
            cameraBasePosition.z
          );
          camera.position.lerp(desiredCameraPos, 0.04);
          camera.lookAt(target_view);
        }

        // Resize
        window.addEventListener('resize', function(){
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Main loop
        function update(){
          requestAnimationFrame(update);
          var delta = clock.getDelta();
          if(backgroundSphere.visible) backgroundUniforms.time.value += delta;
          animateThemeModel(delta);
          if(gameState==='playing'){
            var stepSpeed = ballSpeed;
            if(abilityState.slowTimeActive) stepSpeed *= abilityState.slowFactor || 0.5;
            ball.position.add(ballDirection.clone().multiplyScalar(stepSpeed));
            checkForCollisions();
            lightMouvement();
            updateCameraPosition();
          }
          updatePaddleMotion();
          updateMagicState();
          updateParticleSystems(delta);
          renderer.render(scene, camera);
        }

        function updatePaddleMotion(){
          var limit = playfieldHalfWidth - paddleHitRadius;
          paddleTargetX = THREE.Math.clamp(paddleTargetX, -limit, limit);
          mouseTargetX = THREE.Math.clamp(mouseTargetX, -limit, limit);

          var accel = 0;
          if(keyState.left && !keyState.right) accel -= 2.0;
          if(keyState.right && !keyState.left) accel += 2.0;

          paddleVelocity += accel * 0.14;
          paddleVelocity *= 0.84;
          if(mouseControlActive && !(keyState.left || keyState.right)){
            paddleVelocity += (mouseTargetX - paddle.position.x) * paddleSmoothFactor;
          }
          if(Math.abs(paddleVelocity) < 0.01) paddleVelocity = 0;
          paddleVelocity = THREE.Math.clamp(paddleVelocity, -paddleSpeedCap, paddleSpeedCap);
          paddle.position.x += paddleVelocity;
          clampPaddlePosition();
          if(!(keyState.left || keyState.right)){
            paddleTargetX = mouseControlActive ? mouseTargetX : paddle.position.x;
          }
        }

        function updateMagicState(){
          if(!selectedPaddleProfile){
            abilityStatusEl.textContent = '—';
            return;
          }
          var now = performance.now();
          if(abilityState.fireballActive && now >= abilityState.fireballEnd){
            abilityState.fireballActive = false;
            restoreBallAppearance();
          }
          if(abilityState.slowTimeActive && now >= abilityState.slowEnd){
            abilityState.slowTimeActive = false;
            if(slowParticles) slowParticles.visible = false;
          }
          if(abilityState.iceWallActive && now >= abilityState.iceWallEnd){
            deactivateIceWall();
          }
          if(!abilityReady && now >= abilityCooldownEnd && !isAbilityActive()){ abilityReady = true; }
          updateAbilityUI();
        }

        function updateAbilityUI(){
          if(!selectedPaddleProfile){
            abilityStatusEl.textContent = '—';
            return;
          }
          var now = performance.now();
          var ability = selectedPaddleProfile.ability;
          if(isAbilityActive()){
            abilityStatusEl.textContent = ability.name + ' active';
          } else {
            var remaining = Math.max(0, abilityCooldownEnd - now);
            if(remaining <= 0){
              abilityStatusEl.textContent = ability.name + ' ready (press F)';
            } else {
              abilityStatusEl.textContent = 'Cooling down ' + (remaining/1000).toFixed(1) + 's';
            }
          }
        }

        function isAbilityActive(){
          var now = performance.now();
          return abilityState.fireballActive || abilityState.slowTimeActive || (abilityState.iceWallActive && abilityState.iceWallEnd > now);
        }

        function activateMagicPower(){
          if(!selectedPaddleProfile || gameState !== 'playing') return;
          var now = performance.now();
          if(!abilityReady || now < abilityCooldownEnd) return;
          var ability = selectedPaddleProfile.ability;
          abilityReady = false;
          abilityCooldownEnd = now + (ability.cooldown || 15000);
          abilityActiveUntil = now + (ability.duration || 4000);
          if(ability.type === 'fireball'){
            activateFireballAbility(ability);
          } else if(ability.type === 'iceWall'){
            activateIceWallAbility();
          } else if(ability.type === 'slow'){
            activateSlowAbility(ability.factor || 0.5);
          }
          showMessage('Ability: ' + ability.name, 1400);
          updateAbilityUI();
          magicKeyPressed = false;
        }

        function applyFireballVisual(){
          ballMaterial.color.setHex(0xff6b2c);
          ballMaterial.emissive.setHex(0xff3d00);
          ballMaterial.emissiveIntensity = Math.max(ballMaterial.emissiveIntensity, 1.4);
          if(ballGlow && ballGlow.material){
            ballGlow.material.color.setHex(0xffa94d);
            ballGlow.material.opacity = Math.max(0.45, ballGlow.material.opacity);
          }
          if(ballLight){
            ballLight.color.setHex(0xff7b1a);
            ballLight.intensity = Math.max(ballLight.intensity, 1.9);
          }
        }

        function restoreBallAppearance(){
          ballMaterial.color.copy(ballBaseColor);
          ballMaterial.emissive.copy(ballBaseEmissive);
          ballMaterial.emissiveIntensity = ballBaseEmissiveIntensity;
          if(ballGlow && ballGlow.material){
            ballGlow.material.color.copy(ballGlowBaseColor);
            ballGlow.material.opacity = ballGlowBaseOpacity;
          }
          if(ballLight){
            ballLight.color.copy(ballLightBaseColor);
            ballLight.intensity = ballLightBaseIntensity;
          }
          if(fireParticles){ fireParticles.visible = false; }
        }

        function activateFireballAbility(ability){
          abilityState.fireballActive = true;
          abilityState.fireballEnd = abilityActiveUntil;
          abilityState.fireballRadius = ability.radius || 2.6;
          ensureFireParticles();
          if(fireParticles){
            for(var i=0;i<fireParticleData.length;i++){
              var d = fireParticleData[i];
              d.angle = Math.random() * Math.PI * 2;
              d.radius = 0.65 + Math.random() * 0.45;
              fireParticlePositions[i*3] = Math.cos(d.angle) * d.radius;
              fireParticlePositions[i*3 + 1] = Math.sin(d.angle) * d.radius;
              fireParticlePositions[i*3 + 2] = 0;
            }
            fireParticles.geometry.attributes.position.needsUpdate = true;
            fireParticles.visible = true;
          }
          applyFireballVisual();
          playSfx('magicFire');
        }

        function ensureIceWallMesh(){
          if(abilityState.iceWallMesh) return abilityState.iceWallMesh;
          var geometry = new THREE.BoxGeometry(55, 0.6, 0.8);
          var material = new THREE.MeshPhongMaterial({
            color: 0x7dd3fc,
            transparent: true,
            opacity: 0.55,
            emissive: 0x38bdf8,
            emissiveIntensity: 0.35
          });
          var wall = new THREE.Mesh(geometry, material);
          wall.position.set(0, iceWallY, 0);
          wall.visible = false;
          scene.add(wall);
          abilityState.iceWallMesh = wall;
          return wall;
        }

        function activateIceWallAbility(){
          var wall = ensureIceWallMesh();
          wall.visible = true;
          wall.scale.set(1,1,1);
          abilityState.iceWallActive = true;
          abilityState.iceWallEnd = abilityActiveUntil;
          ensureIceParticles();
          if(iceParticles) iceParticles.visible = true;
          playSfx('magicIce');
        }

        function deactivateIceWall(){
          abilityState.iceWallActive = false;
          abilityState.iceWallEnd = 0;
          if(abilityState.iceWallMesh){ abilityState.iceWallMesh.visible = false; }
          if(iceParticles){ iceParticles.visible = false; }
        }

        function activateSlowAbility(factor){
          abilityState.slowTimeActive = true;
          abilityState.slowEnd = abilityActiveUntil;
          abilityState.slowFactor = THREE.Math.clamp(factor || 0.5, 0.2, 0.8);
          ensureSlowParticles();
          if(slowParticles && slowParticleData){
            for(var i=0;i<slowParticleData.count;i++){
              var phase = Math.random() * Math.PI * 2;
              var radius = 0.9 + Math.random() * 0.35;
              slowParticleData.phases[i] = phase;
              slowParticleData.radius[i] = radius;
              slowParticleData.speed[i] = 1 + Math.random() * 1.2;
              slowParticleData.positions[i*3] = Math.cos(phase) * radius;
              slowParticleData.positions[i*3 + 1] = Math.sin(phase) * (radius * 0.6);
              slowParticleData.positions[i*3 + 2] = 0;
            }
            slowParticleData.geometry.attributes.position.needsUpdate = true;
            slowParticles.visible = true;
          }
          playSfx('magicSlow');
        }

        function ensureSlowParticles(){
          if(slowParticles) return slowParticles;
          var count = 48;
          var positions = new Float32Array(count * 3);
          var geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.42,
            sizeAttenuation: true,
            map: getParticleTexture('#c4b5fd'),
            transparent: true,
            opacity: 0.82,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            alphaTest: 0.01
          });
          slowParticles = new THREE.Points(geometry, material);
          slowParticles.frustumCulled = false;
          slowParticles.visible = false;
          slowParticleData = {
            geometry: geometry,
            positions: positions,
            phases: new Array(count),
            speed: new Array(count),
            radius: new Array(count),
            count: count
          };
          for(var i=0;i<count;i++){
            var phase = Math.random() * Math.PI * 2;
            var radius = 0.9 + Math.random() * 0.35;
            slowParticleData.phases[i] = phase;
            slowParticleData.speed[i] = 1 + Math.random() * 1.2;
            slowParticleData.radius[i] = radius;
            positions[i*3] = Math.cos(phase) * radius;
            positions[i*3 + 1] = Math.sin(phase) * (radius * 0.6);
            positions[i*3 + 2] = 0;
          }
          geometry.attributes.position.needsUpdate = true;
          ball.add(slowParticles);
          return slowParticles;
        }

        function ensureFireParticles(){
          if(fireParticles) return fireParticles;
          var count = 42;
          fireParticlePositions = new Float32Array(count * 3);
          var geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(fireParticlePositions, 3));
          var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.55,
            sizeAttenuation: true,
            map: getParticleTexture('#ff8a42'),
            transparent: true,
            opacity: 0.95,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            alphaTest: 0.01
          });
          fireParticles = new THREE.Points(geometry, material);
          fireParticles.frustumCulled = false;
          fireParticles.visible = false;
          fireParticleData = [];
          for(var i=0;i<count;i++){
            var radius = 0.65 + Math.random() * 0.45;
            var angle = Math.random() * Math.PI * 2;
            fireParticleData.push({ radius: radius, angle: angle, speed: 1.6 + Math.random()*1.4, wobble: 0.35 + Math.random()*0.4 });
            fireParticlePositions[i*3] = Math.cos(angle) * radius;
            fireParticlePositions[i*3 + 1] = Math.sin(angle) * radius;
            fireParticlePositions[i*3 + 2] = 0;
          }
          geometry.attributes.position.needsUpdate = true;
          ball.add(fireParticles);
          return fireParticles;
        }

        function ensureIceParticles(){
          if(iceParticles) return iceParticles;
          var count = 80;
          iceParticlePositions = new Float32Array(count * 3);
          var geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(iceParticlePositions, 3));
          var material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.58,
            sizeAttenuation: true,
            map: getParticleTexture('#9fd8ff'),
            transparent: true,
            opacity: 0.78,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            alphaTest: 0.01
          });
          iceParticles = new THREE.Points(geometry, material);
          iceParticles.frustumCulled = false;
          iceParticles.visible = false;
          iceParticleData = [];
          for(var i=0;i<count;i++){
            var offsetX = (Math.random() - 0.5) * 50;
            var offsetZ = (Math.random() - 0.5) * 1.4;
            var heightOffset = Math.random() * 1.2;
            iceParticleData.push({ baseX: offsetX, baseZ: offsetZ, height: heightOffset, phase: Math.random()*Math.PI*2, speed: 1 + Math.random()*1.4, amplitude: 0.4 + Math.random()*0.3 });
            iceParticlePositions[i*3] = offsetX;
            iceParticlePositions[i*3 + 1] = iceWallY + 0.4 + heightOffset;
            iceParticlePositions[i*3 + 2] = offsetZ;
          }
          geometry.attributes.position.needsUpdate = true;
          scene.add(iceParticles);
          return iceParticles;
        }

        function updateParticleSystems(delta){
          var time = performance.now() * 0.0015;
          if(fireParticles && fireParticles.visible){
            var pos = fireParticles.geometry.attributes.position;
            for(var i=0;i<fireParticleData.length;i++){
              var data = fireParticleData[i];
              data.angle += data.speed * delta;
              var wobble = Math.sin(time * 0.9 + data.angle * 2.2) * data.wobble;
              var x = Math.cos(data.angle) * data.radius;
              var y = Math.sin(data.angle) * (data.radius * 0.85) + wobble * 0.3;
              var z = wobble * 0.45;
              pos.setXYZ(i, x, y, z);
            }
            pos.needsUpdate = true;
          }
          if(iceParticles && iceParticles.visible){
            var icePos = iceParticles.geometry.attributes.position;
            var t = performance.now()*0.001;
            for(var j=0;j<iceParticleData.length;j++){
              var info = iceParticleData[j];
              var angle = t * info.speed + info.phase;
              var x = info.baseX + Math.sin(angle) * 0.65;
              var y = iceWallY + 0.4 + Math.abs(Math.cos(angle * 1.7)) * info.amplitude + info.height;
              var z = info.baseZ + Math.sin(angle * 1.5) * 0.45;
              icePos.setXYZ(j, x, y, z);
            }
            icePos.needsUpdate = true;
          }
          if(slowParticles && slowParticles.visible && slowParticleData){
            var slowPos = slowParticles.geometry.attributes.position;
            var count = slowParticleData.count;
            var t2 = performance.now()*0.0012;
            for(var k=0;k<count;k++){
              var phi = slowParticleData.phases[k] + slowParticleData.speed[k] * delta;
              slowParticleData.phases[k] = phi;
              var r = slowParticleData.radius[k];
              var x = Math.cos(phi) * r;
              var y = Math.sin(phi) * (r * 0.6);
              var z = Math.sin(t2 + phi * 2.6) * 0.38;
              slowPos.setXYZ(k, x, y, z);
            }
            slowPos.needsUpdate = true;
          }
          if(wizzEffects.length){
            for(var w=wizzEffects.length-1; w>=0; w--){
              var effect = wizzEffects[w];
              effect.age += delta;
              var ring = effect.points.geometry.attributes.position;
              var spin = effect.spin * delta;
              for(var i=0;i<effect.count;i++){
                var angle = effect.angles[i] + spin;
                effect.angles[i] = angle;
                var radius = effect.radius * (1 + Math.sin(effect.age * 6 + i * 0.08) * 0.05);
                var x = Math.cos(angle) * radius;
                var z = Math.sin(angle) * radius;
                var y = Math.sin(angle * 2.1 + effect.age * 5) * effect.wave;
                ring.setXYZ(i, x, y, z);
              }
              ring.needsUpdate = true;
              var fade = 1 - (effect.age / effect.life);
              effect.points.material.opacity = Math.max(0, fade * 0.95);
              if(effect.age >= effect.life){
                scene.remove(effect.points);
                effect.points.geometry.dispose();
                effect.points.material.dispose();
                wizzEffects.splice(w,1);
              }
            }
          }
          if(fadingBlocks.length){
            for(var f=fadingBlocks.length-1; f>=0; f--){
              var entry = fadingBlocks[f];
              entry.age += delta;
              var tFade = 1 - (entry.age / entry.life);
              if(entry.mesh.material){
                entry.mesh.material.opacity = Math.max(0, tFade);
                entry.mesh.material.needsUpdate = true;
              }
              entry.mesh.scale.setScalar(1 + (1 - tFade) * 0.25);
              if(entry.age >= entry.life){
                scene.remove(entry.mesh);
                if(entry.mesh.material && entry.mesh.material.dispose){ entry.mesh.material.dispose(); }
                fadingBlocks.splice(f,1);
              }
            }
          }
          if(brickBursts.length){
            for(var b = brickBursts.length - 1; b >= 0; b--){
              var burst = brickBursts[b];
              burst.age += delta;
              var attr = burst.points.geometry.attributes.position;
              for(var p=0;p<burst.positions.length/3;p++){
                var vxIndex = p*3;
                burst.velocities[vxIndex + 1] -= (burst.fire ? 18 : 12) * delta;
                burst.velocities[vxIndex] *= 0.93;
                burst.velocities[vxIndex + 2] *= 0.93;
                burst.positions[vxIndex] += burst.velocities[vxIndex] * delta * 0.05;
                burst.positions[vxIndex + 1] += burst.velocities[vxIndex + 1] * delta * 0.05;
                burst.positions[vxIndex + 2] += burst.velocities[vxIndex + 2] * delta * 0.05;
                attr.setXYZ(p, burst.positions[vxIndex], burst.positions[vxIndex + 1], burst.positions[vxIndex + 2]);
              }
              attr.needsUpdate = true;
              var fadeBurst = 1 - (burst.age / burst.life);
              burst.points.material.opacity = Math.max(0, fadeBurst * (burst.fire ? 1 : 0.78));
              if(burst.age >= burst.life){
                scene.remove(burst.points);
                burst.points.geometry.dispose();
                burst.points.material.dispose();
                brickBursts.splice(b, 1);
              }
            }
          }
        }

        // Start in menu
        enterMenuState();

        // initial I/O
        function checkForIOInteraction(){
          // legacy hook kept for compatibility - no logic here
        }
        checkForIOInteraction();

        function unlockAudioOnInteraction(){
          if(!audioEnabled) return;
          ensureAudioReady(true);
          resumeMusic();
        }

        ['pointerdown','touchstart','keydown'].forEach(function(evt){
          window.addEventListener(evt, unlockAudioOnInteraction, { once: true });
        });

        update();
      </script>
    </body>
  </html>
