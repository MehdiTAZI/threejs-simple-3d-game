<!DOCTYPE html>
  <!--
  TODO :
    Organize code
    Add Physics and sound engines
    Add textures and 3D Objects
  -->
  <html>
    <head>
      <title>Breaker Game</title>
      <script src="https://cdn.jsdelivr.net/npm/three@0.119.1/build/three.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.119.1/examples/js/loaders/GLTFLoader.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/three@0.119.1/examples/js/loaders/RGBELoader.js"></script>
      <!--
      <script src="https://cdn.jsdelivr.net/npm/cannon@0.7.0/build/cannon.min.js"></script>
      -->
      <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAnUlEQVQ4T+WSwQ2DMBBFX1AEUpAEtKAP0KAHpYAO0KAHxwW3cym1iS3mZ93zz2cCcGwhCE2AGHcAiLkj4M9zQQux3ApsAHuABWkK8pPAJuK9aygJ6a1AFGx6SkgKiNR/xicqqLdJd1p1An0So2S1xgEtPYpMyg7MqNjD30tjNPkXvu5Bkrfbpv25CZVw4lIw5ruDc6gX2o37C6GQWJymSxhZ1aAAAAAElFTkSuQmCC" />
      <style>
        body {
          margin: 0;
          font-family: Arial, Helvetica, sans-serif;
          background: radial-gradient(circle at 30% 20%, #1f2937, #0f172a 55%, #020617 100%);
          color: #fff;
        }
        body::before {
          content: "";
          position: fixed;
          inset: 0;
          background: url('https://media.giphy.com/media/26AHONQ79FdWZhAI0/giphy.gif') center/cover no-repeat fixed;
          opacity: 0.2;
          mix-blend-mode: screen;
          pointer-events: none;
          z-index: -2;
          animation: bgFade 24s ease-in-out infinite;
        }
        canvas { width: 100%; height: 100%; display: block; }
        /* HUD */
        #hud {
          position: absolute;
          left: 12px;
          top: 12px;
          color: #fff;
          z-index: 10;
          padding: 10px 14px;
          background: rgba(17, 24, 39, 0.6);
          border-radius: 10px;
          backdrop-filter: blur(4px);
          text-shadow: 0 0 6px rgba(0,0,0,0.7);
        }
        #hud .line { margin-bottom: 6px; }
        #hud .metric { display: flex; align-items: baseline; gap: 6px; }
        #hud .label { font-size: 13px; letter-spacing: .04em; text-transform: uppercase; opacity: 0.7; }
        #hud .value { font-weight: 700; color: #4ade80; }
        #hud .value.alert { color: #facc15; }
        #controls {
          position: absolute;
          right: 12px;
          top: 12px;
          color: #fff;
          z-index: 10;
          text-align: right;
        }
        #controls .btn-row { margin-top: 6px; }
        #volume-control {
          margin-top: 10px;
          font-size: 12px;
          color: #bfdbfe;
        }
        #volume-control input[type="range"] {
          width: 160px;
          accent-color: #38bdf8;
        }
        #message {
          position: absolute;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          color: #fff;
          z-index: 11;
          font-size: 24px;
          background: rgba(0,0,0,0.5);
          padding: 12px 18px;
          border-radius: 8px;
          display: none;
        }
        #achievements { margin-top: 8px; font-size: 12px; color: #ffeb3b; }
        #scene-banner {
          position: absolute;
          left: 50%;
          top: 14px;
          transform: translateX(-50%);
          color: #e0f2fe;
          font-size: 18px;
          letter-spacing: 0.04em;
          text-transform: uppercase;
          padding: 6px 12px;
          border-radius: 20px;
          background: rgba(8, 47, 73, 0.65);
          box-shadow: 0 0 12px rgba(14, 165, 233, 0.35);
          z-index: 9;
          opacity: 0.6;
          transition: opacity 0.8s ease;
        }
        @keyframes bgFade {
          0% { opacity: 0.18; }
          50% { opacity: 0.28; }
          100% { opacity: 0.18; }
        }
        .modal {
          position: fixed;
          inset: 0;
          background: rgba(10, 11, 25, 0.86);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 30;
          transition: opacity 0.4s ease;
        }
        .modal.hidden { opacity: 0; pointer-events: none; }
        .modal-content {
          background: rgba(15, 23, 42, 0.92);
          border: 1px solid rgba(148, 163, 184, 0.3);
          border-radius: 18px;
          padding: 28px 32px;
          max-width: 760px;
          width: 90%;
          box-shadow: 0 20px 60px rgba(2, 6, 23, 0.55);
          color: #e2e8f0;
        }
        .modal-content h2 {
          margin: 0 0 18px;
          font-size: 26px;
          text-align: center;
          letter-spacing: .04em;
        }
        .paddle-grid {
          display: grid;
          gap: 16px;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          margin-bottom: 18px;
        }
        .paddle-card {
          background: rgba(30, 41, 59, 0.85);
          border: 1px solid transparent;
          border-radius: 14px;
          padding: 18px;
          text-align: left;
          color: inherit;
          cursor: pointer;
          transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        }
        .paddle-card .title { font-size: 18px; font-weight: 700; margin-bottom: 10px; }
        .paddle-card .stats { font-size: 14px; color: #cbd5f5; margin-bottom: 8px; }
        .paddle-card .ability { font-size: 13px; color: #facc15; }
        .paddle-card:hover { transform: translateY(-3px); border-color: rgba(59, 130, 246, 0.7); box-shadow: 0 10px 24px rgba(30, 64, 175, 0.32); }
        .paddle-card.active { border-color: rgba(244, 114, 182, 0.9); box-shadow: 0 10px 26px rgba(236, 72, 153, 0.35); }
        .modal-footer {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 8px;
          font-size: 13px;
          color: #cbd5f5;
        }
        #select-confirm {
          background: linear-gradient(135deg, #6366f1, #8b5cf6);
          border: none;
          border-radius: 999px;
          padding: 10px 22px;
          color: #fff;
          font-weight: 600;
          cursor: pointer;
          transition: opacity 0.2s ease;
        }
        #select-confirm:disabled { opacity: 0.45; cursor: not-allowed; }
      </style>
    </head>
    <body>
      <canvas id="game-canvas"></canvas>

      <div id="hud">
        <div class="line metric"><span class="label">Score</span><span class="value" id="score">0</span></div>
        <div class="line metric"><span class="label">Best</span><span class="value" id="best-score">0</span></div>
        <div class="line metric"><span class="label">Combo</span><span class="value" id="combo">x1</span></div>
        <div class="line metric"><span class="label">Lives</span><span class="value" id="lives">3</span></div>
        <div class="line metric"><span class="label">Level</span><span class="value" id="level">1</span></div>
        <div class="line metric"><span class="label">Ability</span><span class="value" id="ability-status">—</span></div>
        <div class="line" style="margin-top:8px;font-size:12px;color:#bae6fd;">
          Quest: <span id="quest">—</span>
        </div>
        <div id="achievements">Achievements: <span id="ach-list">—</span></div>
      </div>

      <div id="scene-banner">Init</div>

      <div id="controls">
        <div>Controls: arrows / mouse • Magic: press F</div>
        <div class="btn-row"><button id="start-btn">Start</button> <button id="pause-btn">Pause</button> <button id="restart-btn">Restart</button> <button id="audio-btn">Audio: on</button></div>
        <div id="volume-control">Volume: <input id="volume-range" type="range" min="0" max="100" value="80" /></div>
      </div>

      <div id="message"></div>

      <div id="paddle-select" class="modal">
        <div class="modal-content">
          <h2>Choose your paddle</h2>
          <div class="paddle-grid">
            <button class="paddle-card" data-key="titan">
              <div class="title">Crimson Titan</div>
              <div class="stats">Wide reach - Heavy control</div>
              <div class="ability">Ability: Energy shield</div>
            </button>
            <button class="paddle-card" data-key="aero">
              <div class="title">Azure Aero</div>
              <div class="stats">Ultra fast - Slim profile</div>
              <div class="ability">Ability: Instant dash</div>
            </button>
            <button class="paddle-card" data-key="mystic">
              <div class="title">Violet Mystic</div>
              <div class="stats">Balanced - Precise control</div>
              <div class="ability">Ability: Time slow</div>
            </button>
          </div>
          <div class="modal-footer">
            <span id="paddle-details">Select a paddle to inspect its stats.</span>
            <button id="select-confirm" disabled>Confirm</button>
          </div>
        </div>
      </div>

      <script>
        // Basic scene + renderer
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0 , 20);
        var target_view = new THREE.Vector3(0, 0, 0);
        camera.lookAt(target_view);

        var renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("game-canvas"), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111827);
        renderer.outputEncoding = THREE.sRGBEncoding;
        var clock = new THREE.Clock();
        var cameraBasePosition = new THREE.Vector3(0, -1.4, 20);
        camera.position.copy(cameraBasePosition);

        // Light
        var light = new THREE.PointLight(0xffffff, 1.2, 120);
        light.position.set(0, 0, 12);
        scene.add(light);
        var ambientLight = new THREE.AmbientLight(0x334155, 0.7);
        scene.add(ambientLight);

        var themeGroup = new THREE.Group();
        scene.add(themeGroup);

        // Background dome with soft gradient
        var backgroundUniforms = {
          colorTop: { value: new THREE.Color(0x0b1a32) },
          colorBottom: { value: new THREE.Color(0x111827) },
          time: { value: 0 }
        };

        function getRGBELoader(){
          if(hdriLoader) return hdriLoader;
          if(typeof THREE.RGBELoader === 'function'){
            hdriLoader = new THREE.RGBELoader();
            hdriLoader.setDataType(THREE.UnsignedByteType);
          }
          return hdriLoader;
        }
        var backgroundMaterial = new THREE.ShaderMaterial({
          side: THREE.BackSide,
          uniforms: backgroundUniforms,
          vertexShader: `
            varying float vHeight;
            void main(){
              vHeight = normalize(position).y * 0.5 + 0.5;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 colorTop;
            uniform vec3 colorBottom;
            uniform float time;
            varying float vHeight;
            void main(){
              float wave = sin(time * 0.1 + vHeight * 5.0) * 0.04;
              float mixVal = smoothstep(0.0, 1.0, vHeight + wave);
              vec3 col = mix(colorBottom, colorTop, mixVal);
              gl_FragColor = vec4(col, 1.0);
            }
          `
        });
        var backgroundSphere = new THREE.Mesh(new THREE.SphereGeometry(220, 48, 32), backgroundMaterial);
        scene.add(backgroundSphere);

        // Paddle (groupe + placeholder)
        var paddle = new THREE.Group();
        var paddlePlaceholderMaterial = new THREE.MeshStandardMaterial({ color: 0x60a5fa, metalness: 0.55, roughness: 0.3, emissive: 0x2563eb, emissiveIntensity: 0.5 });
        var paddleCenter = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 5.5, 32), paddlePlaceholderMaterial);
        paddleCenter.rotation.z = Math.PI / 2;
        var paddleCapLeft = new THREE.Mesh(new THREE.SphereGeometry(0.7, 28, 20), paddlePlaceholderMaterial);
        var paddleCapRight = paddleCapLeft.clone();
        paddleCapLeft.position.set(-2.8, 0, 0.2);
        paddleCapRight.position.set(2.8, 0, 0.2);
        paddle.add(paddleCenter);
        paddle.add(paddleCapLeft);
        paddle.add(paddleCapRight);
        var paddleGlowMaterial = new THREE.MeshBasicMaterial({ color: 0xbae6fd, transparent: true, opacity: 0.32 });
        var paddleGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 6.2, 32), paddleGlowMaterial);
        paddleGlow.rotation.z = Math.PI / 2;
        paddle.add(paddleGlow);
        var paddleLight = new THREE.PointLight(0x93c5fd, 1.4, 18);
        paddleLight.position.set(0, 0, 1.2);
        paddle.add(paddleLight);
        var paddleFrameMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x1f4ed8, emissiveIntensity: 0.25, metalness: 0.8, roughness: 0.15 });
        var paddleFrame = new THREE.Mesh(new THREE.TorusGeometry(3, 0.15, 16, 48), paddleFrameMaterial);
        paddleFrame.rotation.set(Math.PI / 2, 0, 0);
        paddleFrame.position.set(0, 0, -0.3);
        paddle.add(paddleFrame);
        var paddleStrutMaterial = new THREE.MeshStandardMaterial({ color: 0xeff6ff, metalness: 0.7, roughness: 0.3, emissive: 0x1d4ed8, emissiveIntensity: 0.18 });
        var strutGeo = new THREE.BoxGeometry(0.3, 0.3, 1.6);
        var strutLeft = new THREE.Mesh(strutGeo, paddleStrutMaterial);
        var strutRight = strutLeft.clone();
        strutLeft.position.set(-2.2, 0, -0.2);
        strutRight.position.set(2.2, 0, -0.2);
        paddle.add(strutLeft);
        paddle.add(strutRight);
        paddle.position.set(0, -10, 0);
        scene.add(paddle);
        var paddleModel = null;
        var paddlePlaceholderParts = [paddleCenter, paddleCapLeft, paddleCapRight, paddleGlow, paddleFrame, strutLeft, strutRight];
        var paddleHitRadius = 3.2;
        var paddleVelocity = 0;
        var paddleTargetX = 0;
        var mouseTargetX = 0;
        var mouseControlActive = false;
        var paddleSmoothFactor = 0.18;
        var paddleSpeedCap = 2.4;
        paddleTargetX = paddle.position.x;
        updatePaddleHitRadius();
        loadPaddleModel();

        // Ball + light aura
        var ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        var ballMaterial = new THREE.MeshStandardMaterial({
          color: 0x60a5fa,
          emissive: 0x2f88ff,
          emissiveIntensity: 0.65,
          metalness: 0.55,
          roughness: 0.25
        });
        var ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(0, -8, 0);
        var ballGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.7, 24, 18),
          new THREE.MeshBasicMaterial({ color: 0x90cdf4, transparent: true, opacity: 0.25 })
        );
        ball.add(ballGlow);
        var ballLight = new THREE.PointLight(0x6ec1ff, 1.3, 12);
        ballLight.position.set(0, 0, 0.5);
        ball.add(ballLight);
        scene.add(ball);

        var textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous');
        var hdriLoader = null;
        var gltfLoader = null;

        function getGLTFLoader(onReady, attempt){
          attempt = attempt || 0;
          if(typeof THREE.GLTFLoader === 'function'){
            if(!gltfLoader){
              try {
                gltfLoader = new THREE.GLTFLoader();
              } catch(err){
                console.warn('GLTFLoader init failed', err);
                gltfLoader = null;
              }
            }
            if(gltfLoader){
              onReady(gltfLoader);
              return;
            }
          }
          if(attempt >= 25){
            console.warn('GLTFLoader non disponible: utilisation des placeholders.');
            onReady(null);
            return;
          }
          setTimeout(function(){ getGLTFLoader(onReady, attempt + 1); }, 200);
        }

        // Bricks group
        var blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        var brickGroup = new THREE.Group();
        scene.add(brickGroup);
        var blocks = [];

        // Game state & HUD
        var gameState = 'menu'; // 'menu' | 'playing' | 'paused' | 'gameover'
        var score = 0;
        var lives = 3;
        var level = 1;
        var achievements = {};
        var powerUps = [];
        var bestScore = loadBestScore();
        var comboCount = 0;
        var comboTimeout = null;
        var comboResetDelay = 1800;
        var quest = createQuest();
        var totalBlocksDestroyed = 0;

        var currentTheme = null;
        var currentThemeModel = null;
        var currentThemeBaseY = 0;
        var stageBanner = document.getElementById('scene-banner');
        var currentThemeMixer = null;
        var currentThemeAnimation = null;
        var audioEnabled = true;
        var audioUnlocked = false;
        var audioVolume = 0.8;
        var audioCtx = null;
        var masterGain = null;
        var sfxGain = null;
        var musicGain = null;
        var musicNodes = [];
        var currentMusicSource = null;
        var musicBuffers = {};
        var musicTrackLoading = {};
        var currentMusicTheme = null;
        var pendingMusicTheme = null;
        var musicTimer = null;
        var paddleProfiles = {
          titan: {
            name: 'Crimson Titan',
            description: 'Wide reach, heavy handling',
            colors: { primary: 0xea3b5b, emissive: 0x9f1239, glow: 0xfca5a5, light: 0xff7b9d },
            scale: 1.55,
            smooth: 0.12,
            speedCap: 1.35,
            ability: { name: 'Energy shield', type: 'shield', cooldown: 16000, duration: 4500 }
          },
          aero: {
            name: 'Azure Aero',
            description: 'Ultra fast, slim profile',
            colors: { primary: 0x38bdf8, emissive: 0x1d4ed8, glow: 0x93c5fd, light: 0x60a5fa },
            scale: 0.9,
            smooth: 0.28,
            speedCap: 2.7,
            ability: { name: 'Instant dash', type: 'dash', cooldown: 9000, duration: 1200 }
          },
          mystic: {
            name: 'Violet Mystic',
            description: 'Balanced, time control',
            colors: { primary: 0x8b5cf6, emissive: 0x5b21b6, glow: 0xc4b5fd, light: 0xa855f7 },
            scale: 1.1,
            smooth: 0.2,
            speedCap: 2.05,
            ability: { name: 'Time slow', type: 'slow', cooldown: 13000, duration: 5000, factor: 0.45 }
          }
        };
        var selectedPaddleKey = null;
        var selectedPaddleProfile = null;
        var abilityCooldownEnd = 0;
        var abilityActiveUntil = 0;
        var abilityReady = false;
        var abilityState = { shieldActive: false, shieldMesh: null, shieldEnd: 0, dashBoostEnd: 0, slowTimeActive: false, slowEnd: 0, slowFactor: 0.5 };

        var ballDirection = new THREE.Vector3(0.7, 0.7, 0).normalize();
        var baseBallSpeed = 0.28;
        var ballSpeed = baseBallSpeed;
        var maxBallSpeed = 0.62;
        var ballSpeedGrowth = 0.015;
        var tempVec1 = new THREE.Vector3();
        var tempVec2 = new THREE.Vector3();

        function updateHUD(){
          document.getElementById('score').textContent = score;
          document.getElementById('lives').textContent = lives;
          document.getElementById('level').textContent = level;
          document.getElementById('best-score').textContent = bestScore;
          var comboValue = 'x' + comboMultiplier();
          var comboEl = document.getElementById('combo');
          comboEl.textContent = comboValue;
          if(comboMultiplier() > 1){ comboEl.classList.add('alert'); } else { comboEl.classList.remove('alert'); }

          var keys = Object.keys(achievements).filter(k => achievements[k]).join(', ');
          document.getElementById('ach-list').textContent = keys.length ? keys : '—';
          updateQuestHUD();
        }

        function showMessage(text, timeout){
          var el = document.getElementById('message');
          el.textContent = text;
          el.style.display = 'block';
          if(timeout) setTimeout(()=> el.style.display='none', timeout);
        }

        function loadBestScore(){
          try {
            var stored = window.localStorage.getItem('breaker-best-score');
            return stored ? parseInt(stored, 10) || 0 : 0;
          } catch(err) {
            console.warn('Stockage local indisponible', err);
            return 0;
          }
        }

        function saveBestScore(value){
          if(value > bestScore){
            bestScore = value;
            try { window.localStorage.setItem('breaker-best-score', bestScore); }
            catch(err){ console.warn('Impossible de sauvegarder le meilleur score', err); }
          }
        }

        function comboMultiplier(){
          return Math.max(1, 1 + Math.floor(comboCount / 3));
        }

        function resetCombo(){
          comboCount = 0;
          if(comboTimeout) { clearTimeout(comboTimeout); comboTimeout = null; }
        }

        function setBallDirection(x, y){
          var dir = new THREE.Vector3(x, y, 0);
          if(dir.lengthSq() === 0){
            dir.set(0.0001, 1, 0);
          }
          ballDirection.copy(dir.normalize());
        }

        function randomizeBallDirection(){
          var minAngle = THREE.Math.degToRad(35);
          var maxAngle = THREE.Math.degToRad(70);
          var angle = minAngle + Math.random() * (maxAngle - minAngle);
          var horizontal = Math.random() < 0.5 ? -1 : 1;
          setBallDirection(Math.sin(angle) * horizontal, Math.cos(angle));
          stabiliseBallDirection();
        }

        function resetBallPosition(){
          ball.position.set(0, -8, 0);
          randomizeBallDirection();
          ballSpeed = baseBallSpeed;
        }

        function stabiliseBallDirection(minY){
          minY = minY || 0.24;
          if(Math.abs(ballDirection.y) < minY){
            ballDirection.y = minY * (ballDirection.y >= 0 ? 1 : -1 || 1);
          }
          ballDirection.normalize();
        }

        function accelerateBall(multiplier){
          ballSpeed = Math.min(maxBallSpeed, ballSpeed * multiplier);
        }

        function boostCombo(){
          comboCount++;
          if(comboTimeout) clearTimeout(comboTimeout);
          comboTimeout = setTimeout(function(){ resetCombo(); updateHUD(); }, comboResetDelay);
        }

        function createQuest(){
          var target = 15 + Math.floor(Math.random() * 10);
          var reward = 120 + target * 8;
          return {
            description: 'Break ' + target + ' bricks',
            target: target,
            progress: 0,
            reward: reward,
            completed: false
          };
        }

        function updateQuestHUD(){
          var questEl = document.getElementById('quest');
          if(!quest){ questEl.textContent = '—'; return; }
          var progressText = quest.completed ? 'Done! +' + quest.reward : quest.progress + '/' + quest.target;
          if(!quest.completed) progressText += ' | +' + quest.reward;
          questEl.textContent = quest.description + ' (' + progressText + ')';
        }

        function tryCompleteQuest(){
          if(quest && !quest.completed && quest.progress >= quest.target){
            quest.completed = true;
            score += quest.reward;
            saveBestScore(score);
            showMessage('Quest complete! +' + quest.reward + ' pts', 2200);
            updateHUD();
            setTimeout(function(){ quest = createQuest(); updateQuestHUD(); }, 2500);
          }
        }

        function resetQuest(){
          quest = createQuest();
          updateQuestHUD();
        }

        function setSceneBanner(text){
          stageBanner.textContent = text;
          stageBanner.style.opacity = 1;
          setTimeout(function(){ stageBanner.style.opacity = 0.55; }, 1600);
        }

        var selectionModal = document.getElementById('paddle-select');
        var paddleCards = Array.prototype.slice.call(document.querySelectorAll('.paddle-card'));
        var selectConfirm = document.getElementById('select-confirm');
        var paddleDetails = document.getElementById('paddle-details');
        var abilityStatusEl = document.getElementById('ability-status');

        function openSelectionModal(){
          selectionModal.classList.remove('hidden');
        }

        function closeSelectionModal(){
          selectionModal.classList.add('hidden');
        }

        function applyPaddleProfile(key){
          var profile = paddleProfiles[key];
          if(!profile) return;
          selectedPaddleKey = key;
          selectedPaddleProfile = profile;
          paddle.scale.set(profile.scale, 1, 1);
          paddleSmoothFactor = profile.smooth;
          paddleSpeedCap = profile.speedCap;
          paddlePlaceholderMaterial.color.setHex(profile.colors.primary);
          paddlePlaceholderMaterial.emissive.setHex(profile.colors.emissive);
          paddleGlowMaterial.color.setHex(profile.colors.glow);
          paddleFrameMaterial.color.setHex(0xffffff);
          paddleFrameMaterial.emissive.setHex(profile.colors.glow);
          paddleFrameMaterial.emissiveIntensity = 0.28;
          paddleStrutMaterial.color.setHex(0xf8fafc);
          paddleStrutMaterial.emissive.setHex(profile.colors.emissive);
          paddleStrutMaterial.emissiveIntensity = 0.22;
          paddleLight.color.setHex(profile.colors.light);
          paddleLight.intensity = 1.5;
          updatePaddleHitRadius();
          clampPaddlePosition();
          paddleTargetX = paddle.position.x;
          resetAbilityState();
          updateAbilityUI();
        }

        function resetAbilityState(){
          abilityCooldownEnd = 0;
          abilityActiveUntil = 0;
          abilityReady = !!selectedPaddleProfile;
          if(abilityState.shieldMesh){ abilityState.shieldMesh.visible = false; }
          abilityState.shieldActive = false;
          abilityState.dashBoostEnd = 0;
          abilityState.slowTimeActive = false;
        }

        paddleCards.forEach(function(card){
          card.addEventListener('click', function(){
            paddleCards.forEach(c => c.classList.remove('active'));
            card.classList.add('active');
            var key = card.getAttribute('data-key');
            var profile = paddleProfiles[key];
            if(profile){
              paddleDetails.textContent = profile.description + ' — ability: ' + profile.ability.name + ' (press F)';
              selectConfirm.disabled = false;
              selectConfirm.setAttribute('data-key', key);
            }
          });
        });

        selectConfirm.addEventListener('click', function(){
          var key = selectConfirm.getAttribute('data-key');
          if(!key) return;
          applyPaddleProfile(key);
          closeSelectionModal();
        });

        var sfxPresets = {
          paddle: { freq: 540, freqEnd: 420, attack: 0.01, release: 0.18, gain: 0.35, type: 'triangle' },
          block: { freq: 500, freqEnd: 360, attack: 0.015, release: 0.22, gain: 0.32, type: 'sine' },
          powerup: { freq: 660, freqEnd: 880, attack: 0.02, release: 0.45, gain: 0.28, type: 'sine' },
          lifeLost: { freq: 220, freqEnd: 120, attack: 0.03, release: 0.8, gain: 0.35, type: 'sawtooth' },
          levelUp: { freq: 520, freqEnd: 780, attack: 0.02, release: 0.5, gain: 0.32, type: 'triangle' },
          gameOver: { freq: 150, freqEnd: 70, attack: 0.04, release: 1.2, gain: 0.38, type: 'triangle' }
        };

        var musicPresets = {
          'Synthwave Nebula': {
            volume: 0.26,
            waveform: 'sine',
            noteGain: 0.08,
            filter: { type: 'lowpass', freq: 780, Q: 0.7 },
            chords: [
              { notes: [220, 330, 440], duration: 4.5, attack: 1.2, release: 1.6, pause: 1.3 },
              { notes: [247, 370, 494], duration: 4.6, attack: 1.4, release: 1.7, pause: 1.4 },
              { notes: [196, 294, 392], duration: 5.2, attack: 1.3, release: 1.9, pause: 1.6 }
            ]
          },
          'Cosmic Garden': {
            volume: 0.23,
            waveform: 'triangle',
            noteGain: 0.07,
            filter: { type: 'lowpass', freq: 560, Q: 0.9 },
            chords: [
              { notes: [261.63, 329.63, 392.00], duration: 6.0, attack: 1.8, release: 2.2, pause: 1.8 },
              { notes: [293.66, 369.99, 440.00], duration: 5.6, attack: 1.6, release: 2.0, pause: 1.5 }
            ]
          },
          'Orbital Station': {
            volume: 0.25,
            waveform: 'sawtooth',
            noteGain: 0.065,
            filter: { type: 'lowpass', freq: 980, Q: 0.6 },
            chords: [
              { notes: [207.65, 311.13, 415.30], duration: 5.2, attack: 1.2, release: 1.8, pause: 1.2 },
              { notes: [233.08, 349.23, 466.16], duration: 4.8, attack: 1.1, release: 1.7, pause: 1.1 },
              { notes: [185.00, 277.18, 369.99], duration: 5.4, attack: 1.4, release: 2.0, pause: 1.3 }
            ]
          },
          default: {
            volume: 0.2,
            waveform: 'sine',
            noteGain: 0.07,
            filter: { type: 'lowpass', freq: 650, Q: 0.8 },
            chords: [
              { notes: [220, 330, 440], duration: 5.4, attack: 1.3, release: 1.9, pause: 1.5 }
            ]
          }
        };

        var musicTracks = {
          'Synthwave Nebula': {
            url: 'resources/background1.mp3',
            volume: 0.26,
            loop: true
          },
          'Cosmic Garden': {
            url: 'resources/background2.mp3',
            volume: 0.22,
            loop: true
          },
          'Orbital Station': {
            url: 'resources/background3.mp3',
            volume: 0.25,
            loop: true
          },
          default: {
            url: 'resources/background4.mp3',
            volume: 0.24,
            loop: true
          }
        };

        function initAudioEngine(){
          if(audioCtx) return;
          var AudioCtx = window.AudioContext || window.webkitAudioContext;
          if(!AudioCtx) {
          console.warn('AudioContext not supported in this browser.');
            audioEnabled = false;
            return;
          }
          audioCtx = new AudioCtx();
          masterGain = audioCtx.createGain();
          masterGain.connect(audioCtx.destination);
          sfxGain = audioCtx.createGain();
          sfxGain.connect(masterGain);
          musicGain = audioCtx.createGain();
          musicGain.gain.value = 0;
          musicGain.connect(masterGain);
          applyAudioVolume();
        }

        function applyAudioVolume(){
          if(!masterGain) return;
          var target = audioEnabled ? audioVolume : 0;
          if(audioCtx){
            masterGain.gain.setTargetAtTime(target, audioCtx.currentTime, 0.08);
          } else {
            masterGain.gain.value = target;
          }
        }

        function setMasterVolume(value){
          audioVolume = Math.max(0, Math.min(1, value));
          applyAudioVolume();
        }

        function triggerTone(spec){
          if(!audioCtx || audioCtx.state === 'suspended') return;
          var osc = audioCtx.createOscillator();
          var gain = audioCtx.createGain();
          osc.type = spec.type || 'sine';
          osc.frequency.value = spec.freq;
          if(spec.detune) osc.detune.value = spec.detune;
          var now = audioCtx.currentTime;
          var attack = spec.attack !== undefined ? spec.attack : 0.02;
          var release = spec.release !== undefined ? spec.release : (spec.decay || 0.3);
          var peak = (spec.gain || 0.4);
          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.linearRampToValueAtTime(peak, now + attack);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + attack + release);
          if(spec.freqEnd){
            osc.frequency.exponentialRampToValueAtTime(spec.freqEnd, now + attack + release);
          }
          osc.connect(gain);
          gain.connect(spec.targetGain || sfxGain);
          osc.start(now);
          osc.stop(now + attack + release + 0.05);
          osc.onended = function(){
            try { osc.disconnect(); } catch(err){}
            try { gain.disconnect(); } catch(err){}
          };
          return { osc: osc, gain: gain };
        }

        function playSfx(key){
          if(!audioEnabled || !audioUnlocked) return;
          if(!audioCtx) return;
          var spec = sfxPresets[key];
          if(!spec) return;
          if(audioCtx.state === 'suspended'){
            audioCtx.resume().then(function(){ triggerTone(spec); }).catch(()=>{});
          } else {
            triggerTone(spec);
          }
        }

        function stopThemeMusic(){
          if(musicTimer){
            clearTimeout(musicTimer);
            musicTimer = null;
          }
          if(audioCtx && musicGain){
            try {
              musicGain.gain.cancelScheduledValues(audioCtx.currentTime);
              musicGain.gain.setTargetAtTime(0.0001, audioCtx.currentTime, 0.4);
            } catch(err) {}
          }
          if(currentMusicSource){
            try { currentMusicSource.stop(); } catch(err) {}
            try { currentMusicSource.disconnect(); } catch(err) {}
            currentMusicSource = null;
          }
          if(musicNodes.length){
            var now = audioCtx ? audioCtx.currentTime : 0;
            musicNodes.forEach(function(node){
              try {
                node.gain.gain.cancelScheduledValues(now);
                node.gain.gain.setTargetAtTime(0.0001, now, 0.5);
                node.osc.stop(now + 0.8);
              } catch(err) {}
              if(node.lfo){
                try { node.lfo.stop(now + 0.8); } catch(err) {}
                try { node.lfo.disconnect(); } catch(err) {}
              }
              if(node.lfoGain){ try { node.lfoGain.disconnect(); } catch(err) {} }
              if(node.filter){ try { node.filter.disconnect(); } catch(err) {} }
              try { node.gain.disconnect(); } catch(err) {}
              try { node.osc.disconnect(); } catch(err) {}
            });
            musicNodes.length = 0;
          }
          currentMusicTheme = null;
          pendingMusicTheme = null;
        }

        function loadMusicBuffer(url){
          if(musicBuffers[url]) return Promise.resolve(musicBuffers[url]);
          if(musicTrackLoading[url]) return musicTrackLoading[url];
          if(!audioCtx) return Promise.reject(new Error('Audio context not ready'));
          var pending = fetch(url).then(function(response){
            if(!response.ok){
              throw new Error('Music request failed with status ' + response.status);
            }
            return response.arrayBuffer();
          }).then(function(data){
            return new Promise(function(resolve, reject){
              audioCtx.decodeAudioData(data, function(buffer){
                musicBuffers[url] = buffer;
                resolve(buffer);
              }, function(err){ reject(err); });
            });
          });
          musicTrackLoading[url] = pending.then(function(buffer){
            delete musicTrackLoading[url];
            return buffer;
          }, function(err){
            delete musicTrackLoading[url];
            throw err;
          });
          return musicTrackLoading[url];
        }

        function playProceduralMusic(themeName){
          var preset = musicPresets[themeName] || musicPresets.default;
          if(!preset || !preset.chords || !preset.chords.length){
            currentMusicTheme = themeName;
            pendingMusicTheme = null;
            return;
          }

          if(musicGain){
            var targetVol = preset.volume !== undefined ? preset.volume : 0.3;
            musicGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.6);
          }

          var chordIndex = 0;
          var waveform = preset.waveform || 'sine';
          var noteGain = preset.noteGain || 0.12;

          function playChord(){
            if(!audioCtx || audioCtx.state === 'closed'){ return; }
            if(musicTimer){ clearTimeout(musicTimer); musicTimer = null; }
            var data = preset.chords[chordIndex % preset.chords.length];
            chordIndex++;
            var now = audioCtx.currentTime;
            var attack = data.attack || 1.0;
            var release = data.release || 1.5;
            var duration = data.duration || 4.0;
            var pause = data.pause || 1.0;

            data.notes.forEach(function(freq){
              var osc = audioCtx.createOscillator();
              osc.type = waveform;
              osc.frequency.setValueAtTime(freq, now);
              var gainNode = audioCtx.createGain();
              gainNode.gain.setValueAtTime(0.0001, now);
              gainNode.gain.linearRampToValueAtTime(noteGain, now + attack);
              gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration + release);

              var filter = null;
              if(preset.filter){
                filter = audioCtx.createBiquadFilter();
                filter.type = preset.filter.type || 'lowpass';
                filter.frequency.value = preset.filter.freq || 900;
                filter.Q.value = preset.filter.Q || 1;
                osc.connect(filter);
                filter.connect(gainNode);
              } else {
                osc.connect(gainNode);
              }

              if(musicGain){
                gainNode.connect(musicGain);
              } else if(masterGain){
                gainNode.connect(masterGain);
              } else {
                gainNode.connect(audioCtx.destination);
              }

              var entry = { osc: osc, gain: gainNode, filter: filter };
              osc.onended = function(){
                try { osc.disconnect(); } catch(err){}
                try { gainNode.disconnect(); } catch(err){}
                if(filter){ try { filter.disconnect(); } catch(err){} }
                var i = musicNodes.indexOf(entry);
                if(i>=0) musicNodes.splice(i,1);
              };

              osc.start(now);
              osc.stop(now + duration + release + 0.2);
              musicNodes.push(entry);
            });

            musicTimer = setTimeout(playChord, (duration + pause) * 1000);
          }

          playChord();
          currentMusicTheme = themeName;
          pendingMusicTheme = null;
        }

        function startThemeMusic(themeName){
          if(!audioEnabled) return;
          if(!audioCtx){
            pendingMusicTheme = themeName;
            return;
          }
          if(audioCtx.state === 'suspended'){
            audioCtx.resume().then(function(){ startThemeMusic(themeName); }).catch(()=>{});
            return;
          }

          var track = musicTracks[themeName] || musicTracks.default;
          stopThemeMusic();
          currentMusicTheme = themeName;
          pendingMusicTheme = null;

          if(track && track.url){
            var targetVol = track.volume !== undefined ? track.volume : 0.3;
            if(musicGain){
              try {
                musicGain.gain.cancelScheduledValues(audioCtx.currentTime);
                musicGain.gain.setValueAtTime(0.0001, audioCtx.currentTime);
              } catch(err) {}
            }
            loadMusicBuffer(track.url).then(function(buffer){
              if(!audioCtx || audioCtx.state === 'closed') return;
              if(currentMusicTheme !== themeName) return;
              var source = audioCtx.createBufferSource();
              source.buffer = buffer;
              source.loop = track.loop !== false;
              if(track.loopStart !== undefined) source.loopStart = track.loopStart;
              if(track.loopEnd !== undefined) source.loopEnd = track.loopEnd;
              source.connect(musicGain || masterGain || audioCtx.destination);
              currentMusicSource = source;
              source.onended = function(){
                if(currentMusicSource === source) currentMusicSource = null;
              };
              var startAt = audioCtx.currentTime + 0.05;
              try {
                source.start(startAt);
              } catch(err){
                console.warn('Unable to start streamed music', err);
              }
              if(musicGain){
                musicGain.gain.setTargetAtTime(targetVol, startAt, 0.8);
              } else if(masterGain){
                masterGain.gain.setTargetAtTime(targetVol, startAt, 0.8);
              }
            }).catch(function(err){
              console.warn('Falling back to procedural music for theme', themeName, err);
              playProceduralMusic(themeName);
            });
            return;
          }

          playProceduralMusic(themeName);
        }

        function queueThemeMusic(theme){
          pendingMusicTheme = theme.name;
          if(audioUnlocked && audioCtx) startThemeMusic(theme.name);
        }

        function resumeMusic(){
          if(!audioEnabled) return;
          if(!audioUnlocked) return;
          if(!audioCtx){
            initAudioEngine();
            if(pendingMusicTheme) startThemeMusic(pendingMusicTheme);
            return;
          }
          audioCtx.resume().then(function(){
            if(pendingMusicTheme && pendingMusicTheme !== currentMusicTheme){
              startThemeMusic(pendingMusicTheme);
            }
          }).catch(function(err){ console.warn('Impossible de reprendre l\'audio', err); });
        }

        function pauseMusic(){
          if(audioCtx && audioCtx.state === 'running'){
            audioCtx.suspend().catch(()=>{});
          }
        }

        function ensureAudioReady(){
          if(audioUnlocked) return;
          audioUnlocked = true;
          initAudioEngine();
          if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
          if(pendingMusicTheme) startThemeMusic(pendingMusicTheme);
        }

        function toggleAudio(){
          audioEnabled = !audioEnabled;
          var btn = document.getElementById('audio-btn');
          btn.textContent = 'Audio: ' + (audioEnabled ? 'on' : 'off');
          if(audioEnabled){
            ensureAudioReady();
            resumeMusic();
          } else {
            pauseMusic();
          }
          applyAudioVolume();
        }

        THREE.Cache.enabled = true;

        var sceneThemes = [
          {
            name: 'Synthwave Nebula',
            clearColor: 0x0b1120,
            fog: { near: 45, far: 120 },
            ambientColor: 0x1e40af,
            ambientIntensity: 0.9,
            keyColor: 0xf97316,
            keyIntensity: 1.4,
            floorColor: 0x172554,
            modelUrl: 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf',
            modelScale: [4.2, 4.2, 4.2],
            modelPosition: { x: 12, y: 4.5, z: -6 },
            animation: 'spin',
            background: {
              texture: 'https://images.pexels.com/photos/713046/pexels-photo-713046.jpeg?auto=compress&cs=tinysrgb&w=1920',
              floor: 'https://images.pexels.com/photos/158028/pexels-photo-158028.jpeg?auto=compress&cs=tinysrgb&w=1600'
            }
          },
          {
            name: 'Cosmic Garden',
            clearColor: 0x02140c,
            fog: { near: 35, far: 90 },
            ambientColor: 0x16a34a,
            ambientIntensity: 0.8,
            keyColor: 0x4ade80,
            keyIntensity: 1.2,
            floorColor: 0x0f5132,
            modelUrl: 'https://threejs.org/examples/models/gltf/Flamingo.glb',
            modelScale: [0.06, 0.06, 0.06],
            modelPosition: { x: -14, y: 5.5, z: -8 },
            animation: 'float',
            background: {
              texture: 'https://images.pexels.com/photos/443446/pexels-photo-443446.jpeg?auto=compress&cs=tinysrgb&w=1920',
              floor: 'https://images.pexels.com/photos/1486974/pexels-photo-1486974.jpeg?auto=compress&cs=tinysrgb&w=1600'
            }
          },
          {
            name: 'Orbital Station',
            clearColor: 0x0a0a0f,
            fog: { near: 60, far: 160 },
            ambientColor: 0x64748b,
            ambientIntensity: 0.85,
            keyColor: 0x38bdf8,
            keyIntensity: 1.3,
            floorColor: 0x1f2937,
            modelUrl: 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            modelScale: [1.4, 1.4, 1.4],
            modelPosition: { x: 11, y: 3.2, z: -7 },
            animation: 'hover',
            animationClips: ['Dance', 'Jump', 'Wave', 'Walk'],
            animationPause: 700,
            animationFade: 0.4,
            background: {
              texture: 'https://images.pexels.com/photos/220201/pexels-photo-220201.jpeg?auto=compress&cs=tinysrgb&w=1920',
              floor: 'https://images.pexels.com/photos/220326/pexels-photo-220326.jpeg?auto=compress&cs=tinysrgb&w=1600'
            }
          }
        ];

        function hslColor(h, s, l){
          var color = new THREE.Color();
          color.setHSL(h, s, l);
          return color;
        }

        function updatePaddleHitRadius(){
          var bbox = new THREE.Box3().setFromObject(paddle);
          var size = bbox.getSize(new THREE.Vector3());
          if(size.x) paddleHitRadius = Math.max(2.6, size.x / 2);
        }

        function enablePlaceholderPaddle(){
          paddlePlaceholderParts.forEach(function(mesh){ mesh.visible = true; });
          updatePaddleHitRadius();
        }

        function loadPaddleModel(){
          // Decorative booster fins
          var finMaterial = new THREE.MeshStandardMaterial({ color: 0x60a5fa, emissive: 0x2563eb, emissiveIntensity: 0.4, metalness: 0.6, roughness: 0.22 });
          for(var i=-1;i<=1;i+=2){
            var fin = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.4, 16), finMaterial);
            fin.rotation.z = Math.PI/2;
            fin.position.set(i*2.9, 0, -0.6);
            paddle.add(fin);
            paddlePlaceholderParts.push(fin);
          }
          enablePlaceholderPaddle();
        }

        function clampPaddlePosition(){
          var limit = 26 - paddleHitRadius;
          paddle.position.x = THREE.Math.clamp(paddle.position.x, -limit, limit);
          paddleTargetX = THREE.Math.clamp(paddleTargetX, -limit, limit);
        }

        var levelLayouts = [
          function classicLayout(currentLevel, addBlock){
            var width = Math.min(14 + Math.floor(currentLevel * 0.8), 22);
            var height = Math.min(6 + Math.floor(currentLevel / 2), 9);
            var spacing = 1.35;
            for (var i = -Math.floor(width/2); i < Math.ceil(width/2); i++) {
              for (var j = 0; j < height; j++) {
                var hue = 0.55 + (j/height) * 0.15;
                addBlock(i * spacing, j * spacing + 2.2, hslColor(hue % 1, 0.65, 0.52));
              }
            }
          },
          function waveLayout(currentLevel, addBlock){
            var columns = 14 + currentLevel * 2;
            for(var k=0; k<columns; k++){
              var x = (k - columns/2) * 1.5;
              for(var row=0; row<3 + Math.floor(currentLevel/2); row++){
                var y = row * 1.6 + Math.sin((k / 2) + currentLevel) * 1.4 + 3;
                var hue = 0.05 + (k / columns) * 0.25;
                addBlock(x, y, hslColor(hue % 1, 0.7, 0.5));
              }
            }
          },
          function pyramidLayout(currentLevel, addBlock){
            var rows = Math.min(7 + Math.floor(currentLevel / 2), 10);
            var spacing = 1.5;
            for(var row=0; row<rows; row++){
              var blocksInRow = rows - row + 2;
              for(var col=0; col<blocksInRow; col++){
                var x = (col - blocksInRow / 2) * spacing;
                var y = row * spacing + 2.5;
                var hue = 0.7 + (row / rows) * 0.1;
                addBlock(x, y, hslColor(hue % 1, 0.5, 0.58));
              }
            }
          }
        ];

        function buildLevel(){
          while (brickGroup.children.length) brickGroup.remove(brickGroup.children[0]);
          blocks.length = 0;

          var addBlock = function(x, y, color){
            var blockMaterial = new THREE.MeshPhongMaterial({ color: color });
            var block = new THREE.Mesh(blockGeometry, blockMaterial);
            block.position.set(x, y, 0);
            brickGroup.add(block);
            blocks.push(block);
          };

          var layoutIndex = (level - 1) % levelLayouts.length;
          levelLayouts[layoutIndex](level, addBlock);
          applyTheme(level);
        }

        function applyTheme(nextLevel){
          var theme = sceneThemes[(nextLevel - 1) % sceneThemes.length];
          currentTheme = theme;
          currentThemeBaseY = theme.modelPosition.y;

          renderer.setClearColor(theme.clearColor);
          if(theme.fog){
            scene.fog = new THREE.Fog(new THREE.Color(theme.clearColor), theme.fog.near, theme.fog.far);
          } else {
            scene.fog = null;
          }

          ambientLight.color.setHex(theme.ambientColor);
          ambientLight.intensity = theme.ambientIntensity;
          light.color.setHex(theme.keyColor);
          light.intensity = theme.keyIntensity;

          if(currentThemeMixer){
            currentThemeMixer.stopAllAction();
            currentThemeMixer = null;
          }
          stopThemeAnimationCycle();
          currentThemeModel = null;
          while (themeGroup.children.length) themeGroup.remove(themeGroup.children[0]);
          var floorMaterial = new THREE.MeshPhongMaterial({ color: theme.floorColor || 0x222c4a, transparent: true, opacity: 0.9, side: THREE.DoubleSide });
          var floor = new THREE.Mesh(new THREE.PlaneGeometry(160, 160), floorMaterial);
          floor.rotation.x = -Math.PI/2;
          floor.position.set(0, -15.2, -12);
          themeGroup.add(floor);

          var wallMaterial = new THREE.MeshPhongMaterial({ color: 0x1b263b, transparent: true, opacity: 0.85, side: THREE.DoubleSide });
          var wall = new THREE.Mesh(new THREE.PlaneGeometry(160, 110), wallMaterial);
          wall.position.set(0, 25, -40);
          themeGroup.add(wall);

          if(theme.background && theme.background.floor){
            textureLoader.load(theme.background.floor, function(tex){
              tex.encoding = THREE.sRGBEncoding;
              tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
              tex.repeat.set(3, 3);
              if(renderer && renderer.capabilities){
                tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy() || 1);
              }
              floor.material.map = tex;
              floor.material.opacity = 1.0;
              floor.material.color.set(0xffffff);
              floor.material.needsUpdate = true;
            }, undefined, function(){
              floor.material.opacity = 0.4;
              floor.material.map = null;
              floor.material.color.set(theme.floorColor || 0x172554);
            });
          }

          if(theme.background && theme.background.texture){
            textureLoader.load(theme.background.texture, function(tex){
              tex.encoding = THREE.sRGBEncoding;
              tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
              wall.material.map = tex;
              wall.material.opacity = 1.0;
              wall.material.color.set(0xffffff);
              wall.material.needsUpdate = true;
            }, undefined, function(){
              wall.material.opacity = 0.5;
              wall.material.map = null;
              wall.material.color.set(0x1b263b);
            });
          }

          if(theme.background && theme.background.texture){
            textureLoader.load(theme.background.texture, function(tex){
              tex.encoding = THREE.sRGBEncoding;
              if(renderer && renderer.capabilities){
                tex.anisotropy = Math.min(4, renderer.capabilities.getMaxAnisotropy() || 1);
              }
              scene.background = tex;
              backgroundSphere.visible = false;
            }, undefined, function(){
              scene.background = null;
              backgroundSphere.visible = true;
            });
          } else {
            scene.background = null;
            backgroundSphere.visible = true;
          }

          loadThemeModel(theme);
          queueThemeMusic(theme);
          setSceneBanner(theme.name);
        }

        function loadThemeModel(theme){
          getGLTFLoader(function(loader){
            if(!loader){
              console.warn('3D theme loading disabled (GLTFLoader missing).');
              return;
            }
            loader.load(theme.modelUrl, function(gltf){
              if(currentTheme !== theme) return;
              currentThemeModel = gltf.scene;
              currentThemeModel.scale.set(theme.modelScale[0], theme.modelScale[1], theme.modelScale[2]);
              currentThemeModel.position.set(theme.modelPosition.x, theme.modelPosition.y, theme.modelPosition.z);
              currentThemeModel.traverse(function(node){ if(node.isMesh){ node.receiveShadow = false; node.castShadow = false; } });
              themeGroup.add(currentThemeModel);
              currentThemeBaseY = theme.modelPosition.y;
              if(gltf.animations && gltf.animations.length){
                currentThemeMixer = new THREE.AnimationMixer(currentThemeModel);
                setupThemeAnimations(theme, gltf);
              } else {
                currentThemeMixer = null;
                stopThemeAnimationCycle();
              }
            }, undefined, function(err){
              currentThemeModel = null;
              currentThemeMixer = null;
              stopThemeAnimationCycle();
              console.warn('Unable to load theme model', err);
            });
          });
        }

        function stopThemeAnimationCycle(){
          if(currentThemeAnimation){
            if(currentThemeAnimation.timeout) clearTimeout(currentThemeAnimation.timeout);
            if(currentThemeAnimation.currentAction) currentThemeAnimation.currentAction.stop();
          }
          currentThemeAnimation = null;
        }

        function setupThemeAnimations(theme, gltf){
          stopThemeAnimationCycle();
          if(!currentThemeMixer) return;

          var clips = [];
          if(Array.isArray(theme.animationClips) && theme.animationClips.length){
            theme.animationClips.forEach(function(name){
              var clip = THREE.AnimationClip.findByName(gltf.animations, name);
              if(clip) clips.push(clip);
            });
          }
          if(!clips.length) clips = gltf.animations.slice();
          if(!clips.length) return;

          var actions = clips.map(function(clip){
            var action = currentThemeMixer.clipAction(clip);
            action.clampWhenFinished = true;
            action.setLoop(THREE.LoopOnce, 1);
            action.enabled = true;
            return { clip: clip, action: action };
          });

          currentThemeAnimation = {
            actions: actions,
            index: -1,
            fade: theme.animationFade !== undefined ? theme.animationFade : 0.6,
            pause: theme.animationPause !== undefined ? theme.animationPause : 1000,
            timeout: null,
            currentAction: null
          };

          cycleThemeAnimation();
        }

        function cycleThemeAnimation(){
          if(!currentThemeAnimation || !currentThemeAnimation.actions.length) return;
          var state = currentThemeAnimation;
          state.index = (state.index + 1) % state.actions.length;
          var entry = state.actions[state.index];
          var action = entry.action;

          if(state.currentAction && state.currentAction !== action){
            state.currentAction.fadeOut(state.fade);
          }

          action.reset();
          action.fadeIn(state.fade).play();
          state.currentAction = action;

          var duration = Math.max(0.5, entry.clip.duration || 0.5) * 1000;
          if(state.timeout) clearTimeout(state.timeout);
          state.timeout = setTimeout(cycleThemeAnimation, duration + state.pause);
        }

        function animateThemeModel(delta){
          if(currentThemeMixer) currentThemeMixer.update(delta);
          if(!currentThemeModel || !currentTheme || currentThemeMixer) return;
          var time = Date.now() * 0.001;
          if(currentTheme.animation === 'spin'){
            currentThemeModel.rotation.y += 0.003;
          } else if(currentTheme.animation === 'float'){
            currentThemeModel.rotation.y += 0.0025;
            currentThemeModel.position.y = currentThemeBaseY + Math.sin(time * 0.6) * 0.45;
          } else if(currentTheme.animation === 'hover'){
            currentThemeModel.rotation.y = Math.sin(time * 1.1) * 0.18;
            currentThemeModel.position.y = currentThemeBaseY + Math.sin(time * 1.6) * 0.24;
          }
        }

        buildLevel();
        updateHUD();

        // Power-up spawn: sphere that falls; collision with ball activates effect
        function spawnPowerUp(){
          var types = ['expand', 'life', 'score'];
          var type = types[Math.floor(Math.random() * types.length)];
          var palette = {
            expand: { color: 0xffd54f, emissive: 0xffb300, light: 0xffc566 },
            life: { color: 0x4ade80, emissive: 0x22c55e, light: 0x7ef4a5 },
            score: { color: 0x60a5fa, emissive: 0x3b82f6, light: 0x9ccfff }
          };
          var look = palette[type];

          var container = new THREE.Group();
          container.position.set((Math.random()*40)-20, 12, 0);

          var core = new THREE.Mesh(
            new THREE.IcosahedronGeometry(0.55, 0),
            new THREE.MeshStandardMaterial({
              color: look.color,
              emissive: look.emissive,
              emissiveIntensity: 0.75,
              metalness: 0.2,
              roughness: 0.35
            })
          );
          container.add(core);

          var halo = new THREE.Mesh(
            new THREE.SphereGeometry(0.85, 24, 18),
            new THREE.MeshBasicMaterial({ color: look.light, transparent: true, opacity: 0.22 })
          );
          container.add(halo);

          var light = new THREE.PointLight(look.light, 1.1, 10);
          light.position.set(0, 0, 0.4);
          container.add(light);

          container.userData = { type: type, core: core, halo: halo, light: light };
          scene.add(container);
          powerUps.push(container);
          // auto-remove after 12s
          setTimeout(()=>{
            var idx = powerUps.indexOf(container);
            if(idx>=0){
              scene.remove(container);
              powerUps.splice(idx,1);
            }
          }, 12000);
        }
        // spawn periodically when playing
        setInterval(()=>{ if(gameState==='playing' && Math.random()<0.6) spawnPowerUp(); }, 10000);

        // Input: keyboard + mouse
        var keyState = { left: false, right: false };
        document.addEventListener("keydown", function(event) {
          if(event.code==='Space'){
            if(gameState==='playing') { gameState='paused'; pauseMusic(); showMessage('Paused'); }
            else if(gameState==='paused'){ gameState='playing'; document.getElementById('message').style.display='none'; resumeMusic(); }
            updateAbilityUI();
            return;
          }
          if (event.code === "ArrowLeft" || event.code === 'KeyA'){ keyState.left = true; mouseControlActive = false; }
          else if (event.code === "ArrowRight" || event.code === 'KeyD'){ keyState.right = true; mouseControlActive = false; }
        });
        document.addEventListener("keyup", function(event){
          if (event.code === "ArrowLeft" || event.code === 'KeyA'){ keyState.left = false; }
          else if (event.code === "ArrowRight" || event.code === 'KeyD'){ keyState.right = false; }
          else if (event.code === 'KeyF'){ magicKeyPressed = false; }
          if(!keyState.left && !keyState.right){
            paddleTargetX = mouseControlActive ? mouseTargetX : paddle.position.x;
          }
        });
        var magicKeyPressed = false;
        document.addEventListener('keydown', function(event){
          if(event.code === 'KeyF' && !magicKeyPressed){
            magicKeyPressed = true;
            activateMagicPower();
          }
        });
        window.addEventListener('mousemove', function(e){
          // convert screen x to world x (approx)
          var ratio = (e.clientX / window.innerWidth) * 2 - 1;
          var limit = 26 - paddleHitRadius;
          mouseTargetX = THREE.Math.clamp(ratio * 26, -limit, limit);
          mouseControlActive = true;
          paddleTargetX = mouseTargetX;
        });

        // Buttons
        document.getElementById('start-btn').addEventListener('click', function(){ startGame(); });
        document.getElementById('pause-btn').addEventListener('click', function(){
          if(gameState==='playing'){ gameState='paused'; pauseMusic(); showMessage('Paused'); }
          else if(gameState==='paused'){ gameState='playing'; document.getElementById('message').style.display='none'; resumeMusic(); }
          updateAbilityUI();
        });
        document.getElementById('restart-btn').addEventListener('click', function(){
          window.location.href = window.location.origin + window.location.pathname;
        });
        document.getElementById('audio-btn').addEventListener('click', toggleAudio);
        var volumeSlider = document.getElementById('volume-range');
        volumeSlider.value = Math.round(audioVolume * 100);
        volumeSlider.addEventListener('input', function(e){
          if(!audioUnlocked && audioEnabled) ensureAudioReady();
          setMasterVolume((parseInt(e.target.value, 10) || 0) / 100);
        });

        function startGame(){
          if(!selectedPaddleProfile){
            openSelectionModal();
            showMessage('Choose a paddle to get started', 1800);
            return;
          }
          stopThemeMusic();
          ensureAudioReady();
          playSfx('levelUp');
          score = 0; lives = 3; level = 1;
          totalBlocksDestroyed = 0;
          resetCombo();
          resetQuest();
          while(powerUps.length){ var extra = powerUps.pop(); scene.remove(extra); }
          buildLevel();
          baseBallSpeed = 0.28;
          ballSpeed = baseBallSpeed;
          resetBallPosition();
          paddle.position.x = 0;
          paddleTargetX = 0;
          paddleVelocity = 0;
          clampPaddlePosition();
          resetAbilityState();
          updateAbilityUI();
          gameState='playing';
          updateHUD();
          document.getElementById('message').style.display='none';
          resumeMusic();
        }

        // Achievements helper
        function checkAchievements(){
          if(score >= 100 && !achievements['Score 100']){ achievements['Score 100'] = true; showMessage('Achievement: 100 points!', 2000); }
          if(level >= 3 && !achievements['Level 3']){ achievements['Level 3'] = true; showMessage('Achievement: level 3 reached!', 2000); }
          if(comboMultiplier() >= 3 && !achievements['Combo x3']){ achievements['Combo x3'] = true; showMessage('Achievement: combo x3!', 2000); }
          if(totalBlocksDestroyed >= 50 && !achievements['50 bricks']){ achievements['50 bricks'] = true; showMessage('Achievement: 50 bricks destroyed!', 2000); }
          if(quest && quest.completed && !achievements['Quest']){ achievements['Quest'] = true; showMessage('Achievement: quest completed!', 2000); }
          updateHUD();
        }

        // Collision + game logic updates
        function checkForCollisions(){
          if(gameState!=='playing') return;

          // Walls
          if (ball.position.x < -30 || ball.position.x > 27){
            ballDirection.x *= -1;
            ball.position.x = THREE.Math.clamp(ball.position.x, -30, 27);
            stabiliseBallDirection();
          }

          if(abilityState.shieldActive){
            var shieldY = paddle.position.y - 3.5;
            if(ballDirection.y < 0 && ball.position.y <= shieldY + 0.6){
              if(Math.abs(ball.position.x - paddle.position.x) <= paddleHitRadius + 2.6){
                ballDirection.y = Math.abs(ballDirection.y);
                ball.position.y = shieldY + 0.65;
                stabiliseBallDirection(0.32);
                playSfx('powerup');
              }
            }
          }

          if (ball.position.y < -13) {
            lives--;
            playSfx('lifeLost');
            saveBestScore(score);
            resetCombo();
            updateHUD();
            if(lives<=0){
              gameState='gameover';
              showMessage('Game Over - score ' + score, 4200);
              playSfx('gameOver');
              pauseMusic();
              return;
            }
            resetBallPosition();
          }

          if (ball.position.y > 15){
            ballDirection.y *= -1;
            ball.position.y = 15;
            stabiliseBallDirection();
          }

          // Paddle collision
          var paddleHalfWidth = paddleHitRadius;
          var paddleHeight = 1.2;
          if (ball.position.y <= paddle.position.y + paddleHeight && ball.position.y >= paddle.position.y - paddleHeight) {
            if (ball.position.x > paddle.position.x - paddleHalfWidth && ball.position.x < paddle.position.x + paddleHalfWidth) {
              var relative = (ball.position.x - paddle.position.x) / paddleHalfWidth;
              relative = THREE.Math.clamp(relative, -1, 1);
              var bounceAngle = relative * THREE.Math.degToRad(70);
              var newDir = new THREE.Vector3(Math.sin(bounceAngle), Math.cos(bounceAngle), 0);
              if(newDir.y <= 0) newDir.y = Math.abs(newDir.y) || 0.5;
              ballDirection.copy(newDir.normalize());
              ball.position.y = paddle.position.y + paddleHeight + 0.1;
              accelerateBall(1 + (Math.abs(relative) * 0.12));
              playSfx('paddle');
              stabiliseBallDirection(0.32);
            }
          }

          // Blocks collision (simple distance test)
          for (var i = 0; i < blocks.length; i++) {
            var block = blocks[i];
            if (block.position.distanceTo(ball.position) < 1.2) {
              var diffX = Math.abs(ball.position.x - block.position.x);
              var diffY = Math.abs(ball.position.y - block.position.y);
              if(diffX > diffY){
                ballDirection.x *= -1;
              } else {
                ballDirection.y *= -1;
              }
              stabiliseBallDirection();
              accelerateBall(1.02);
              brickGroup.remove(block);
              blocks.splice(i, 1);

              playSfx('block');
              boostCombo();
              var gained = Math.floor(12 * comboMultiplier());
              score += gained;
              totalBlocksDestroyed++;
              if(quest && !quest.completed) quest.progress++;
              if(score > bestScore) saveBestScore(score);
              updateHUD();
              tryCompleteQuest();
              checkAchievements();

              if(blocks.length === 0){
                level++;
                resetCombo();
                while(powerUps.length){ var dropped = powerUps.pop(); scene.remove(dropped); }
                buildLevel();
                baseBallSpeed = Math.min(0.28 + level * ballSpeedGrowth, maxBallSpeed * 0.85);
                ballSpeed = baseBallSpeed;
                resetBallPosition();
                var themeLabel = currentTheme ? currentTheme.name : 'Niveau';
                showMessage('Niveau ' + level + ' - ' + themeLabel, 1800);
                playSfx('levelUp');
              }
              i--;
            }
          }

          // Power-ups falling
          for(var p=0;p<powerUps.length;p++){
            var up = powerUps[p];
            up.position.y -= 0.05;
            up.rotation.y += 0.03;
            if(up.userData && up.userData.halo){
              var halo = up.userData.halo;
              halo.material.opacity = 0.18 + 0.07 * Math.sin(Date.now()*0.002 + p);
            }
            if(up.position.distanceTo(ball.position) < 1.2){
              if(up.userData.type==='expand'){
                paddle.scale.x = 2;
                updatePaddleHitRadius();
                setTimeout(()=>{ paddle.scale.x = 1; updatePaddleHitRadius(); }, 8000);
              showMessage('Power-up: Paddle expanded', 1500);
              playSfx('powerup');
            } else if(up.userData.type==='life'){
                lives++; updateHUD(); showMessage('Power-up: Extra life', 1200);
                playSfx('powerup');
              } else if(up.userData.type==='score'){
                score += 100;
                saveBestScore(score);
                updateHUD();
                showMessage('Power-up: +100 points', 1200);
                playSfx('powerup');
              }
              scene.remove(up);
              powerUps.splice(p,1); p--;
            }
          }
        }

        function lightMouvement(){
          light.position.x = ball.position.x;
          light.position.y = ball.position.y;
        }

        function updateCameraPosition(){
          var focusY = THREE.Math.clamp(ball.position.y * 0.25, -2, 4);
          var focusX = THREE.Math.clamp(ball.position.x * 0.12, -2.8, 2.8);
          var desiredLook = tempVec1.set(focusX, focusY, 0);

          target_view.lerp(desiredLook, 0.04);

          var desiredCameraPos = tempVec2.set(
            cameraBasePosition.x + target_view.x * 0.08,
            cameraBasePosition.y + target_view.y * 0.12,
            cameraBasePosition.z
          );
          camera.position.lerp(desiredCameraPos, 0.04);
          camera.lookAt(target_view);
        }

        // Resize
        window.addEventListener('resize', function(){
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Main loop
        function update(){
          requestAnimationFrame(update);
          var delta = clock.getDelta();
          if(backgroundSphere.visible) backgroundUniforms.time.value += delta;
          animateThemeModel(delta);
          if(gameState==='playing'){
            var stepSpeed = ballSpeed;
            if(abilityState.slowTimeActive) stepSpeed *= abilityState.slowFactor || 0.5;
            ball.position.add(ballDirection.clone().multiplyScalar(stepSpeed));
            checkForCollisions();
            lightMouvement();
            updateCameraPosition();
          }
          updatePaddleMotion();
          updateMagicState();
          renderer.render(scene, camera);
        }

        function updatePaddleMotion(){
          var limit = 26 - paddleHitRadius;
          paddleTargetX = THREE.Math.clamp(paddleTargetX, -limit, limit);
          mouseTargetX = THREE.Math.clamp(mouseTargetX, -limit, limit);

          var accel = 0;
          if(keyState.left && !keyState.right) accel -= 2.0;
          if(keyState.right && !keyState.left) accel += 2.0;

          paddleVelocity += accel * 0.14;
          paddleVelocity *= 0.84;
          if(mouseControlActive && !(keyState.left || keyState.right)){
            paddleVelocity += (mouseTargetX - paddle.position.x) * paddleSmoothFactor;
          }
          if(Math.abs(paddleVelocity) < 0.01) paddleVelocity = 0;
          paddleVelocity = THREE.Math.clamp(paddleVelocity, -paddleSpeedCap, paddleSpeedCap);
          paddle.position.x += paddleVelocity;
          clampPaddlePosition();
          if(!(keyState.left || keyState.right)){
            paddleTargetX = mouseControlActive ? mouseTargetX : paddle.position.x;
          }
        }

        function updateMagicState(){
          if(!selectedPaddleProfile){
            abilityStatusEl.textContent = '—';
            return;
          }
          var now = performance.now();
          if(abilityState.shieldActive && now >= abilityState.shieldEnd){
            abilityState.shieldActive = false;
            if(abilityState.shieldMesh) abilityState.shieldMesh.visible = false;
          }
          if(abilityState.dashBoostEnd && now >= abilityState.dashBoostEnd){
            abilityState.dashBoostEnd = 0;
            paddleGlowMaterial.opacity = 0.32;
            paddleLight.intensity = 1.5;
          }
          if(abilityState.slowTimeActive && now >= abilityState.slowEnd){
            abilityState.slowTimeActive = false;
          }
          if(!abilityReady && now >= abilityCooldownEnd && !isAbilityActive()){ abilityReady = true; }
          updateAbilityUI();
        }

        function updateAbilityUI(){
          if(!selectedPaddleProfile){
            abilityStatusEl.textContent = '—';
            return;
          }
          var now = performance.now();
          var ability = selectedPaddleProfile.ability;
          if(isAbilityActive()){
            abilityStatusEl.textContent = ability.name + ' active';
          } else {
            var remaining = Math.max(0, abilityCooldownEnd - now);
            if(remaining <= 0){
              abilityStatusEl.textContent = ability.name + ' ready (press F)';
            } else {
              abilityStatusEl.textContent = 'Cooling down ' + (remaining/1000).toFixed(1) + 's';
            }
          }
        }

        function isAbilityActive(){
          return abilityState.shieldActive || (abilityState.dashBoostEnd && abilityState.dashBoostEnd > performance.now()) || abilityState.slowTimeActive;
        }

        function activateMagicPower(){
          if(!selectedPaddleProfile || gameState !== 'playing') return;
          var now = performance.now();
          if(!abilityReady || now < abilityCooldownEnd) return;
          var ability = selectedPaddleProfile.ability;
          abilityReady = false;
          abilityCooldownEnd = now + (ability.cooldown || 15000);
          abilityActiveUntil = now + (ability.duration || 4000);
          if(ability.type === 'shield'){
            activateShieldAbility();
          } else if(ability.type === 'dash'){
            activateDashAbility();
          } else if(ability.type === 'slow'){
            activateSlowAbility(ability.factor || 0.5);
          }
          showMessage('Ability: ' + ability.name, 1400);
          updateAbilityUI();
          magicKeyPressed = false;
        }

        function ensureShieldMesh(){
          if(abilityState.shieldMesh) return abilityState.shieldMesh;
          var material = new THREE.MeshBasicMaterial({ color: 0x7dd3fc, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending });
          var mesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 2) , material);
          mesh.rotation.x = -Math.PI/2;
          mesh.position.set(0, paddle.position.y - 3.5, 0);
          mesh.visible = false;
          scene.add(mesh);
          abilityState.shieldMesh = mesh;
          return mesh;
        }

        function activateShieldAbility(){
          var mesh = ensureShieldMesh();
          mesh.material.color.setHex(selectedPaddleProfile.colors ? selectedPaddleProfile.colors.glow : 0x7dd3fc);
          mesh.visible = true;
          mesh.position.set(paddle.position.x, paddle.position.y - 3.5, 0);
          abilityState.shieldActive = true;
          abilityState.shieldEnd = abilityActiveUntil;
        }

        function activateDashAbility(){
          var limit = 26 - paddleHitRadius;
          paddle.position.x = THREE.Math.clamp(ball.position.x, -limit, limit);
          paddleTargetX = paddle.position.x;
          paddleVelocity = 0;
          abilityState.dashBoostEnd = abilityActiveUntil;
          paddleGlowMaterial.opacity = 0.48;
          paddleLight.intensity = 2.2;
        }

        function activateSlowAbility(factor){
          abilityState.slowTimeActive = true;
          abilityState.slowEnd = abilityActiveUntil;
          abilityState.slowFactor = THREE.Math.clamp(factor || 0.5, 0.2, 0.8);
        }

        // Start in menu
        document.getElementById('message').textContent = 'Click "Start" to play';
        document.getElementById('message').style.display = 'block';

        // initial I/O
        function checkForIOInteraction(){
          // legacy hook kept for compatibility - no logic here
        }
        checkForIOInteraction();

        function unlockAudioOnInteraction(){
          if(!audioEnabled || audioUnlocked) return;
          ensureAudioReady();
          resumeMusic();
        }

        ['pointerdown','touchstart','keydown'].forEach(function(evt){
          window.addEventListener(evt, unlockAudioOnInteraction, { once: true });
        });

        update();
      </script>
    </body>
  </html>
